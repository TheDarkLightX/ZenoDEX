schema: zenodex/claims-registry/v1
meta:
  project: ZenoDEX (Autonomous Tau DEX)
  purpose: >
    Machine-readable index of *promoted* safety/liveness claims with replayable checks.
    This is intentionally tool-agnostic: it can point to PopperPad objects, Lean theorems,
    tests, TLC configs, etc.
  note: >
    PopperPad is the recommended *internal* source-of-truth ledger for hypotheses + evidence.
    This registry is the curated/public-facing subset that can be validated in CI without
    requiring PopperPad.

claims:
  - id: py:snapshot:v2_perps_roundtrip_deterministic
    status: supported
    layer: implementation
    statement: >
      Serializing then decoding a DEX snapshot (v2) that includes a non-empty perps state
      yields identical canonical bytes (deterministic round-trip).
    evidence:
      kind: pytest
      check:
        - cmd: pytest -q tests/integration/test_dex_snapshot.py::test_snapshot_roundtrip_with_perps_is_deterministic
      files:
        - tests/integration/test_dex_snapshot.py
        - src/integration/dex_snapshot.py

  - id: py:perp_engine:settle_epoch_order_independent
    status: supported
    layer: implementation
    statement: >
      Settling an epoch across multiple accounts is deterministic and independent of account
      table iteration order (global post-state is consistent across accounts).
    assumptions:
      - Requires ESSO installed (kernel interpreter) to execute the perp epoch risk kernel.
    evidence:
      kind: pytest
      check:
        - cmd: pytest -q tests/integration/test_perp_engine.py::test_settle_epoch_is_order_independent
      files:
        - tests/integration/test_perp_engine.py
        - src/integration/perp_engine.py
        - src/core/perp_epoch.py

  - id: py:perp_engine:settle_epoch_fee_pool_accumulates_across_accounts
    status: supported
    layer: implementation
    statement: >
      When some (but not all) accounts liquidate during settle_epoch, the per-market fee pool
      increases by the sum of per-account liquidation penalties, and the transition remains
      deterministic and independent of account insertion order.
    assumptions:
      - Requires ESSO installed (kernel interpreter) to execute the perp epoch risk kernel.
    evidence:
      kind: pytest
      check:
        - cmd: pytest -q tests/integration/test_perp_engine.py::test_settle_epoch_accumulates_fee_pool_for_mixed_liquidation
      files:
        - tests/integration/test_perp_engine.py
        - src/integration/perp_engine.py

  - id: py:perp_engine:breaker_reduce_only_and_clear
    status: supported
    layer: implementation
    statement: >
      Under the clamp+breaker posture, an out-of-bounds clearing price update deterministically
      triggers the breaker, clamps the mark price, enforces reduce-only position updates while active,
      and allows operator clear only after all positions are closed.
    assumptions:
      - Requires ESSO installed (kernel interpreter) to execute the perp epoch risk kernel.
    evidence:
      kind: pytest
      check:
        - cmd: pytest -q tests/integration/test_perp_engine.py::test_breaker_reduce_only_and_clear
      files:
        - tests/integration/test_perp_engine.py
        - src/integration/perp_engine.py
        - src/kernels/dex/perp_epoch_isolated_v2.yaml

  - id: py:perp_engine:advance_requires_prior_settlement
    status: supported
    layer: implementation
    statement: >
      Operator epoch advancement is fail-closed: the engine rejects advancing again until the
      current epoch has been settled (prevents skipping settlement epochs).
    assumptions:
      - Requires ESSO installed (kernel interpreter) to execute the perp epoch risk kernel.
    evidence:
      kind: pytest
      check:
        - cmd: pytest -q tests/integration/test_perp_engine.py::test_operator_cannot_skip_settlement
      files:
        - tests/integration/test_perp_engine.py
        - src/integration/perp_engine.py

  - id: esso:perp_epoch_isolated_v2:verify_multi_z3_cvc5
    status: supported
    layer: spec
    statement: >
      The default epoch-perp risk kernel is inductive (k=1) and cross-verified by both Z3 and CVC5
      under ESSO's fail-closed verification model.
    evidence:
      kind: esso
      check:
        - cmd: python3 -m ESSO verify-multi src/kernels/dex/perp_epoch_isolated_v2.yaml --solvers z3,cvc5 --timeout-ms 60000 --determinism-trials 2
      files:
        - src/kernels/dex/perp_epoch_isolated_v2.yaml

  - id: esso:perp_epoch_clearinghouse_2p_v0_1:verify_multi_z3_cvc5
    status: supported
    layer: spec
    statement: >
      The 2-party clearinghouse epoch-perp kernel is inductive (k=1) and cross-verified by both Z3 and CVC5
      under ESSO's fail-closed verification model.
    evidence:
      kind: esso
      check:
        - cmd: python3 -m ESSO verify-multi src/kernels/dex/perp_epoch_clearinghouse_2p_v0_1.yaml --solvers z3,cvc5 --timeout-ms 60000 --determinism-trials 2
      files:
        - src/kernels/dex/perp_epoch_clearinghouse_2p_v0_1.yaml

  - id: py:perp_clearinghouse_2p:liquidation_penalty_conservation
    status: supported
    layer: spec
    statement: >
      In the 2-party clearinghouse reference model, a +5% settlement move can deterministically liquidate
      the under-margined side, apply a liquidation penalty into the fee pool, and preserve exact quote-e8
      conservation (net_deposited = collateral_a + collateral_b + fee_pool).
    evidence:
      kind: pytest
      check:
        - cmd: pytest -q tests/core/test_perp_clearinghouse_2p/test_ref_smoke.py
      files:
        - tests/core/test_perp_clearinghouse_2p/test_ref_smoke.py
        - generated/perp_python/perp_epoch_clearinghouse_2p_v0_1_ref.py
        - src/kernels/dex/perp_epoch_clearinghouse_2p_v0_1.yaml

  - id: lean:perp_epoch_safety:collateral_nonneg_after_clamped_move
    status: proved
    layer: math
    statement: >
      Under the bounded-move oracle assumption, and with maintenance margin ≥ max oracle move,
      one clamped price update cannot drive collateral negative (math-only statement over ℚ).
    evidence:
      kind: lean
      check:
        - cmd: bash -lc "cd lean-mathlib && lake build Proofs.PerpEpochSafety"
      files:
        - lean-mathlib/Proofs/PerpEpochSafety.lean
      theorems:
        - Proofs.PerpEpochSafety.collateral_nonneg_after_clamped_move

  - id: py:perp_math:rounding_leak_witness_under_euclidean_division
    status: supported
    layer: math
    statement: >
      Per-account Euclidean division can violate global conservation even under net-zero exposure
      (Σpos=0 does not imply Σpnl=0 when pnl_i := (pos_i·ΔP_e8) div 1e8).
      A minimal witness is captured as a deterministic pytest.
    evidence:
      kind: pytest
      check:
        - cmd: pytest -q tests/core/test_perp_math_hazards.py::test_rounding_leak_witness_under_euclidean_division
      files:
        - tests/core/test_perp_math_hazards.py
        - internal/popperpad_mcp/bootstrap_zenodex_pad.py

  - id: py:perp_math:largest_remainder_dust_allocator_restores_conservation
    status: supported
    layer: implementation
    statement: >
      The deterministic "largest remainder" dust allocator restores conservation under net-zero sums:
      given xs with Σxs=0, it returns integer adjustments whose sum is 0 and each element differs from
      floor(xs_i/d) by at most +1, with deterministic tie-breaking by account key.
    evidence:
      kind: pytest
      check:
        - cmd: pytest -q tests/core/test_perp_math_hazards.py::test_largest_remainder_dust_allocator_restores_net_zero_conservation
      files:
        - tests/core/test_perp_math_hazards.py
        - src/core/perp_rounding.py
        - internal/popperpad_mcp/bootstrap_zenodex_pad.py

  - id: py:perp_math:breaker_quantization_can_stall_witness
    status: supported
    layer: math
    statement: >
      Clamp/breaker bounded-step enforcement can stall when integer quantization yields δ=0
      (δ := floor(P*m_bps/10000)), while the raw oracle price is out of bounds.
      A minimal witness is captured as a deterministic pytest.
    evidence:
      kind: pytest
      check:
        - cmd: pytest -q tests/core/test_perp_math_hazards.py::test_breaker_quantization_can_stall_witness
      files:
        - tests/core/test_perp_math_hazards.py
        - internal/popperpad_mcp/bootstrap_zenodex_pad.py

  - id: lean:zenodex_nonces:no_replay_in_later_valid_seq
    status: proved
    layer: math
    statement: >
      Sequential nonce batches cannot be replayed: a nonce from an accepted batch cannot
      appear in any later valid sequential batch for the same sender.
    evidence:
      kind: lean
      check:
        - cmd: bash -lc "cd lean-mathlib && lake build Proofs.ZenoDEXNonces"
      files:
        - lean-mathlib/Proofs/ZenoDEXNonces.lean
      theorems:
        - Proofs.ZenoDEX.no_replay_in_later_valid_seq

  - id: lean:zenodex_routing:foldl_argmin_key_le_all
    status: proved
    layer: math
    statement: >
      Folding a finite candidate list with an argmin-step returns an element whose key is
      ≤ every candidate key (deterministic tie behavior from the step definition).
    evidence:
      kind: lean
      check:
        - cmd: bash -lc "cd lean-mathlib && lake build Proofs.ZenoDEXRoutingArgmin"
      files:
        - lean-mathlib/Proofs/ZenoDEXRoutingArgmin.lean
      theorems:
        - Proofs.ZenoDEX.foldl_argmin_key_le_all

  - id: lean:zenodex_rounding:ceilDiv_mul_ge
    status: proved
    layer: math
    statement: >
      Standard ceil-division bound: for b>0, a ≤ ceilDiv(a,b)*b + (b-1).
      Used to bound integer rounding error in kernel-style arithmetic.
    evidence:
      kind: lean
      check:
        - cmd: bash -lc "cd lean-mathlib && lake build Proofs.ZenoDEXRounding"
      files:
        - lean-mathlib/Proofs/ZenoDEXRounding.lean
      theorems:
        - Proofs.ZenoDEX.ceilDiv_mul_ge

  - id: tla:perp_epoch_scheduler:terminates_each_epoch
    status: proposed
    layer: liveness
    statement: >
      Under weak fairness of operator actions, every epoch that gets a clearing-price published
      is eventually settled (no deadlock / no stuck-between-phases scheduler behavior).
    evidence:
      kind: tla
      note: >
        Requires TLA+ tools (TLC). This check is optional in CI unless the toolchain is installed.
      check:
        - cmd: tlc -config formal/tla/PerpEpochScheduler.cfg formal/tla/PerpEpochScheduler.tla
      files:
        - formal/tla/PerpEpochScheduler.tla
        - formal/tla/PerpEpochScheduler.cfg

  - id: esso:ltlf:perp_epoch_scheduler:settle_epoch2_reachable
    status: supported
    layer: liveness
    statement: >
      In the finite-trace scheduler micro-model, the operator can reach a state where epoch 2 is settled
      (oracle_last_update_epoch = 2) via the canonical advance/publish/settle cycle. This is a bounded,
      executable complement to the infinite-trace TLA+ liveness check.
    assumptions:
      - Requires ESSO installed (LTLf synthesis gate).
    evidence:
      kind: pytest
      check:
        - cmd: pytest -q tests/formal/test_perp_epoch_scheduler_ltlf.py::test_ltlf_scheduler_can_reach_epoch_2_settled
      files:
        - tests/formal/test_perp_epoch_scheduler_ltlf.py
        - formal/ltlf/perp_epoch_scheduler_ltlf_v1.yaml
