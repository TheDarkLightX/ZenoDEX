schema: zenodex/claims-registry/v1
meta:
  project: ZenoDEX (Autonomous Tau DEX)
  purpose: >
    Machine-readable index of *promoted* safety/liveness claims with replayable checks.
    This is intentionally tool-agnostic: it can point to private evidence objects,
    theorem statements, tests, and model-checking configs.
  note: >
    This registry is the curated subset that can be validated in CI without requiring any
    private evidence ledger.

claims:
  - id: py:snapshot:v2_perps_roundtrip_deterministic
    status: supported
    layer: implementation
    statement: >
      Serializing then decoding a DEX snapshot (v2) that includes a non-empty perps state
      yields identical canonical bytes (deterministic round-trip).
    evidence:
      kind: pytest
      check:
        - cmd: pytest -q tests/integration/test_dex_snapshot.py::test_snapshot_roundtrip_with_perps_is_deterministic
      files:
        - tests/integration/test_dex_snapshot.py
        - src/integration/dex_snapshot.py

  - id: py:perp_engine:settle_epoch_order_independent
    status: supported
    layer: implementation
    statement: >
      Settling an epoch across multiple accounts is deterministic and independent of account
      table iteration order (global post-state is consistent across accounts).
    evidence:
      kind: pytest
      check:
        - cmd: pytest -q tests/integration/test_perp_engine.py::test_settle_epoch_is_order_independent
      files:
        - tests/integration/test_perp_engine.py
        - src/integration/perp_engine.py
        - src/core/perp_epoch.py

  - id: py:perp_engine:settle_epoch_fee_pool_accumulates_across_accounts
    status: supported
    layer: implementation
    statement: >
      When some (but not all) accounts liquidate during settle_epoch, the per-market fee pool
      increases by the sum of per-account liquidation penalties, and the transition remains
      deterministic and independent of account insertion order.
    evidence:
      kind: pytest
      check:
        - cmd: pytest -q tests/integration/test_perp_engine.py::test_settle_epoch_accumulates_fee_pool_for_mixed_liquidation
      files:
        - tests/integration/test_perp_engine.py
        - src/integration/perp_engine.py

  - id: py:perp_engine:breaker_reduce_only_and_clear
    status: supported
    layer: implementation
    statement: >
      Under the clamp+breaker posture, an out-of-bounds clearing price update deterministically
      triggers the breaker, clamps the mark price, enforces reduce-only position updates while active,
      and allows operator clear only after all positions are closed.
    evidence:
      kind: pytest
      check:
        - cmd: pytest -q tests/integration/test_perp_engine.py::test_breaker_reduce_only_and_clear
      files:
        - tests/integration/test_perp_engine.py
        - src/integration/perp_engine.py
        - src/kernels/dex/perp_epoch_isolated_v2.yaml

  - id: py:perp_engine:advance_requires_prior_settlement
    status: supported
    layer: implementation
    statement: >
      Operator epoch advancement is fail-closed: the engine rejects advancing again until the
      current epoch has been settled (prevents skipping settlement epochs).
    evidence:
      kind: pytest
      check:
        - cmd: pytest -q tests/integration/test_perp_engine.py::test_operator_cannot_skip_settlement
      files:
        - tests/integration/test_perp_engine.py
        - src/integration/perp_engine.py

  - id: py:perp_engine_ch2p:net_zero_and_pair_liquidation
    status: supported
    layer: implementation
    statement: >
      The perps tx adapter supports a minimal 2-party clearinghouse posture (perps.version=1.0; legacy 0.2)
      that is fail-closed and deterministic: markets are initialized with exactly two accounts,
      position updates are set as a matched net-zero pair, and settlement/liquidation is executed by
      a spec-derived, deterministic reference implementation while persisting the clearinghouse kernel
      state inside snapshots (perps state v5). Collateral accounting is maintained in quote-e8 units so
      the closed-system invariant holds exactly (net_deposited = collateral_a + collateral_b + fee_pool).
    evidence:
      kind: pytest
      check:
        - cmd: pytest -q tests/integration/test_perp_engine_clearinghouse_2p.py
      files:
        - tests/integration/test_perp_engine_clearinghouse_2p.py
        - src/integration/perp_engine.py
        - src/core/perps.py
        - src/integration/dex_snapshot.py
        - generated/perp_python/perp_epoch_clearinghouse_2p_v0_1_ref.py

  - id: smt:perp_epoch_isolated_v2:inductive_z3_cvc5
    status: supported
    layer: spec
    statement: >
      The default epoch-perp risk kernel is inductive (k=1) and cross-verified by both Z3 and CVC5
      under a fail-closed, multi-solver SMT verification model.
    evidence:
      kind: smt
      check:
        - cmd: bash tools/run_perps_evidence.sh
      files:
        - src/kernels/dex/perp_epoch_isolated_v2.yaml

  - id: smt:perp_epoch_clearinghouse_2p_v0_1:inductive_z3_cvc5
    status: supported
    layer: spec
    statement: >
      The 2-party clearinghouse epoch-perp kernel is inductive (k=1) and cross-verified by both Z3 and CVC5
      under a fail-closed, multi-solver SMT verification model.
    evidence:
      kind: smt
      check:
        - cmd: bash tools/run_perps_evidence.sh
      files:
        - src/kernels/dex/perp_epoch_clearinghouse_2p_v0_1.yaml

  - id: smt:perp_game_theory_v2:inductive_z3_cvc5
    status: supported
    layer: spec
    statement: >
      The 2-party epoch-perp game-theory kernel is inductive (k=1) and cross-verified by both Z3 and CVC5
      under a fail-closed, multi-solver SMT verification model.
    evidence:
      kind: smt
      check:
        - cmd: bash tools/run_perps_evidence.sh
      files:
        - src/kernels/dex/perp_game_theory_v2.yaml

  - id: py:perp_clearinghouse_2p:liquidation_penalty_conservation
    status: supported
    layer: spec
    statement: >
      In the 2-party clearinghouse reference model, a +5% settlement move can deterministically liquidate
      the under-margined side, apply a liquidation penalty into the fee pool, and preserve exact quote-e8
      conservation (net_deposited = collateral_a + collateral_b + fee_pool).
    evidence:
      kind: pytest
      check:
        - cmd: pytest -q tests/core/test_perp_clearinghouse_2p/test_ref_smoke.py
      files:
        - tests/core/test_perp_clearinghouse_2p/test_ref_smoke.py
        - generated/perp_python/perp_epoch_clearinghouse_2p_v0_1_ref.py
        - src/kernels/dex/perp_epoch_clearinghouse_2p_v0_1.yaml

  - id: py:derivatives_generated_refs:smoke_v1
    status: supported
    layer: spec
    statement: >
      The committed, dependency-free Python reference models for v1 derivative kernels import and can
      execute at least one valid step from init state while preserving invariants.
    evidence:
      kind: pytest
      check:
        - cmd: pytest -q tests/core/test_derivatives_generated_refs.py
      files:
        - tests/core/test_derivatives_generated_refs.py
        - generated/derivatives_python/funding_rate_market_v1_ref.py
        - generated/derivatives_python/il_futures_market_v1_ref.py
        - generated/derivatives_python/curve_selection_market_v1_ref.py

  - id: esso:funding_rate_market_v1:verify_multi_z3_cvc5
    status: supported
    layer: spec
    statement: >
      The funding-rate market kernel (v1) is inductive (k=1) and cross-verified by both Z3 and CVC5
      under the kernel verifier's fail-closed verification model.
    evidence:
      kind: esso
      check:
        - cmd: python3 -m ESSO verify-multi src/kernels/dex/funding_rate_market_v1.yaml --solvers z3,cvc5 --timeout-ms 60000 --determinism-trials 2
      files:
        - src/kernels/dex/funding_rate_market_v1.yaml

  - id: esso:il_futures_market_v1:verify_multi_z3_cvc5
    status: supported
    layer: spec
    statement: >
      The IL futures market kernel (v1) is inductive (k=1) and cross-verified by both Z3 and CVC5
      under the kernel verifier's fail-closed verification model.
    evidence:
      kind: esso
      check:
        - cmd: python3 -m ESSO verify-multi src/kernels/dex/il_futures_market_v1.yaml --solvers z3,cvc5 --timeout-ms 60000 --determinism-trials 2
      files:
        - src/kernels/dex/il_futures_market_v1.yaml

  - id: esso:curve_selection_market_v1:verify_multi_z3_cvc5
    status: supported
    layer: spec
    statement: >
      The curve-selection market kernel (v1) is inductive (k=1) and cross-verified by both Z3 and CVC5
      under the kernel verifier's fail-closed verification model.
    evidence:
      kind: esso
      check:
        - cmd: python3 -m ESSO verify-multi src/kernels/dex/curve_selection_market_v1.yaml --solvers z3,cvc5 --timeout-ms 60000 --determinism-trials 2
      files:
        - src/kernels/dex/curve_selection_market_v1.yaml

  - id: lean:perp_epoch_safety:collateral_nonneg_after_clamped_move
    status: proved
    layer: math
    statement: >
      Under the bounded-move oracle assumption, and with maintenance margin ≥ max oracle move,
      one clamped price update cannot drive collateral negative (math-only statement over ℚ).
    evidence:
      kind: lean
      check:
        - cmd: bash -lc "cd lean-mathlib && lake build Proofs.PerpEpochSafety"
      files:
        - lean-mathlib/Proofs/PerpEpochSafety.lean
      theorems:
        - Proofs.PerpEpochSafety.collateral_nonneg_after_clamped_move

  - id: py:perp_math:rounding_leak_witness_under_euclidean_division
    status: supported
    layer: math
    statement: >
      Per-account Euclidean division can violate global conservation even under net-zero exposure
      (Σpos=0 does not imply Σpnl=0 when pnl_i := (pos_i·ΔP_e8) div 1e8).
      A minimal witness is captured as a deterministic pytest.
    evidence:
      kind: pytest
      check:
        - cmd: pytest -q tests/core/test_perp_math_hazards.py::test_rounding_leak_witness_under_euclidean_division
      files:
        - tests/core/test_perp_math_hazards.py

  - id: py:perp_math:largest_remainder_dust_allocator_restores_conservation
    status: supported
    layer: implementation
    statement: >
      The deterministic "largest remainder" dust allocator restores conservation under net-zero sums:
      given xs with Σxs=0, it returns integer adjustments whose sum is 0 and each element differs from
      floor(xs_i/d) by at most +1, with deterministic tie-breaking by account key.
    evidence:
      kind: pytest
      check:
        - cmd: pytest -q tests/core/test_perp_math_hazards.py::test_largest_remainder_dust_allocator_restores_net_zero_conservation
      files:
        - tests/core/test_perp_math_hazards.py
        - src/core/perp_rounding.py

  - id: py:perp_math:breaker_quantization_can_stall_witness
    status: supported
    layer: math
    statement: >
      Clamp/breaker bounded-step enforcement can stall when integer quantization yields δ=0
      (δ := floor(P*m_bps/10000)), while the raw oracle price is out of bounds.
      A minimal witness is captured as a deterministic pytest.
    evidence:
      kind: pytest
      check:
        - cmd: pytest -q tests/core/test_perp_math_hazards.py::test_breaker_quantization_can_stall_witness
      files:
        - tests/core/test_perp_math_hazards.py

  - id: py:perp_incentives:volume_rewards_can_subsidize_oracle_manipulation_witness
    status: supported
    layer: math
    statement: >
      A naive per-leg volume reward can subsidize a spot-derived oracle manipulation loop: even when
      integer quantization yields perp_pnl=0, the reward can exceed the spot roundtrip cost, producing
      net_profit>0. A concrete witness is captured as a deterministic pytest.
    evidence:
      kind: pytest
      check:
        - cmd: pytest -q tests/core/test_perp_incentive_hazards.py::test_volume_rewards_can_subsidize_oracle_manipulation_witness
      files:
        - tests/core/test_perp_incentive_hazards.py

  - id: py:cpmm:lp_fees_are_recapturable_for_full_lp_witness
    status: supported
    layer: math
    statement: >
      When protocol fees are not extracted from a CPMM, swap fees remain in the pool. A trader who is also
      100% of the LP side therefore recaptures the roundtrip loss via pool ownership (combined wallet+pool
      balances are conserved). A concrete witness is captured as a deterministic pytest.
    evidence:
      kind: pytest
      check:
        - cmd: pytest -q tests/core/test_perp_incentive_hazards.py::test_cpmm_lp_fees_are_recapturable_for_full_lp_witness
      files:
        - tests/core/test_perp_incentive_hazards.py

  - id: py:cpmm:protocol_fee_rebate_capped_by_extracted_fees_unprofitable_under_bounds
    status: supported
    layer: math
    statement: >
      For a fixed CPMM configuration (reserves=10_000/10_000, fee_bps=10, protocol_fee_share_bps=10_000,
      rebate_share_bps=10_000), a quote->base->quote roundtrip is not profitable when the rebate is capped
      by extracted protocol fees. This is checked by bounded brute-force over trade_in_quote ∈ [1, 20_000),
      skipping invalid tiny trades where the unwind leg is undefined under exact-in semantics.
    evidence:
      kind: pytest
      check:
        - cmd: pytest -q tests/core/test_perp_incentive_hazards.py::test_protocol_fee_rebate_capped_by_extracted_fees_not_profitable_under_bounds
      files:
        - tests/core/test_perp_incentive_hazards.py

  - id: lean:zenodex_nonces:no_replay_in_later_valid_seq
    status: proved
    layer: math
    statement: >
      Sequential nonce batches cannot be replayed: a nonce from an accepted batch cannot
      appear in any later valid sequential batch for the same sender.
    evidence:
      kind: lean
      check:
        - cmd: bash -lc "cd lean-mathlib && lake build Proofs.ZenoDEXNonces"
      files:
        - lean-mathlib/Proofs/ZenoDEXNonces.lean
      theorems:
        - Proofs.ZenoDEX.no_replay_in_later_valid_seq

  - id: lean:zenodex_routing:foldl_argmin_key_le_all
    status: proved
    layer: math
    statement: >
      Folding a finite candidate list with an argmin-step returns an element whose key is
      ≤ every candidate key (deterministic tie behavior from the step definition).
    evidence:
      kind: lean
      check:
        - cmd: bash -lc "cd lean-mathlib && lake build Proofs.ZenoDEXRoutingArgmin"
      files:
        - lean-mathlib/Proofs/ZenoDEXRoutingArgmin.lean
      theorems:
        - Proofs.ZenoDEX.foldl_argmin_key_le_all

  - id: lean:zenodex_rounding:ceilDiv_mul_ge
    status: proved
    layer: math
    statement: >
      Standard ceil-division bound: for b>0, a ≤ ceilDiv(a,b)*b + (b-1).
      Used to bound integer rounding error in kernel-style arithmetic.
    evidence:
      kind: lean
      check:
        - cmd: bash -lc "cd lean-mathlib && lake build Proofs.ZenoDEXRounding"
      files:
        - lean-mathlib/Proofs/ZenoDEXRounding.lean
      theorems:
        - Proofs.ZenoDEX.ceilDiv_mul_ge

  - id: tla:perp_epoch_scheduler:terminates_each_epoch
    status: proposed
    layer: liveness
    statement: >
      Under weak fairness of operator actions, every epoch that gets a clearing-price published
      is eventually settled (no deadlock / no stuck-between-phases scheduler behavior).
    evidence:
      kind: tla
      note: >
        Requires TLA+ tools (TLC). This check is optional in CI unless the toolchain is installed.
      check:
        - cmd: tlc -config formal/tla/PerpEpochScheduler.cfg formal/tla/PerpEpochScheduler.tla
      files:
        - formal/tla/PerpEpochScheduler.tla
        - formal/tla/PerpEpochScheduler.cfg

  - id: ltlf:perp_epoch_scheduler:settle_epoch2_reachable
    status: supported
    layer: liveness
    statement: >
      In the finite-trace scheduler micro-model, the operator can reach a state where epoch 2 is settled
      (oracle_last_update_epoch = 2) via the canonical advance/publish/settle cycle. This is a bounded,
      executable complement to the infinite-trace TLA+ liveness check.
    evidence:
      kind: pytest
      check:
        - cmd: pytest -q tests/formal/test_perp_epoch_scheduler_ltlf.py::test_ltlf_scheduler_can_reach_epoch_2_settled
      files:
        - tests/formal/test_perp_epoch_scheduler_ltlf.py
        - formal/ltlf/perp_epoch_scheduler_ltlf_v1.yaml
