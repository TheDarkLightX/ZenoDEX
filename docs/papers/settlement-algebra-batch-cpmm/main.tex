% Initial draft (v0). This paper is intended to be readable and rigorous, with
% mechanized proofs referenced by Lean theorem names and file paths.
\documentclass[11pt]{article}

\usepackage[margin=1in]{geometry}
\usepackage{amsmath,amssymb,amsthm,mathtools}
\usepackage{hyperref}
\usepackage[nameinlink,noabbrev]{cleveref}
\usepackage{enumitem}
\usepackage{microtype}

\hypersetup{
  colorlinks=true,
  linkcolor=blue,
  citecolor=blue,
  urlcolor=blue
}

\newtheorem{definition}{Definition}
\newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}
\newtheorem{proposition}{Proposition}
\newtheorem{corollary}{Corollary}
\theoremstyle{remark}
\newtheorem{remark}{Remark}

\newcommand{\Z}{\mathbb{Z}}
\newcommand{\N}{\mathbb{N}}
\newcommand{\floor}[1]{\left\lfloor #1 \right\rfloor}
\newcommand{\abs}[1]{\left| #1 \right|}

\title{Settlement Algebra and Verified Constant-Product Invariants\\for Batch DEX Execution}
\author{(draft; authors TBD)}
\date{\today}

\begin{document}
\maketitle

\begin{abstract}
We present a small, compositional mathematical model for decentralized exchange (DEX)
execution and prove key safety invariants for constant-product market makers (CPMMs),
including a closed-form expression for the \emph{exact} per-swap increase in the product
invariant. The development is mechanized in Lean 4/Mathlib.

The paper has three main layers:
(i) an additive \emph{settlement algebra} capturing token flows as a commutative group,
with a homomorphism $\Delta$ to a scalar ``net flow'';
(ii) a correctness-by-construction objective for batch auctions maximizing executed
volume and surplus in lexicographic order; and
(iii) a CPMM state-transition model with verified $K$-monotonicity and an exact
``$K$-gap'' remainder theorem, lifted compositionally to batches and bridged to the
settlement/objective layers by a refinement lemma.
\end{abstract}

\section{Overview and scope}
\label{sec:overview}

This draft explains the mathematics and formal logic embodied by the Lean files:
\begin{itemize}[leftmargin=2em]
  \item \texttt{lean-mathlib/Proofs/SettlementAlgebra.lean}: additive settlement model and the homomorphism $\Delta$.
  \item \texttt{lean-mathlib/Proofs/BatchOptimality.lean}: batch objective $(A,B)$ (volume, surplus) and lexicographic comparison.
  \item \texttt{lean-mathlib/Proofs/CPMMInvariants.lean}: CPMM safety theorems, including the closed-form $K$-gap.
  \item \texttt{lean-mathlib/Proofs/CPMMSettlement.lean}: bridge from CPMM swaps to settlements.
  \item \texttt{lean-mathlib/Proofs/BatchCPMMUnification.lean}: unification: batch settlement safety, batch optimality additivity,
        and compositional $K$ theorems for sequential swap batches.
\end{itemize}

\paragraph{Important semantic caveat.}
Throughout, we distinguish:
\begin{itemize}[leftmargin=2em]
  \item \emph{Scalar net-flow} $\Delta(s)=\Delta x + \Delta y$ which adds different token units and is therefore
        \emph{not} a notion of economic value conservation; and
  \item the \emph{CPMM invariant} $K=x\cdot y$ which is the standard, economically meaningful conservation law for constant-product pools.
\end{itemize}
The Lean development makes this distinction explicit and proves $K$-monotonicity as the primary invariant.

\section{Preliminaries}
\label{sec:prelim}

We write $\N=\{0,1,2,\dots\}$ and $\Z$ for the integers.
For $d\in\N$ with $d>0$, Euclidean division states that for every $N\in\N$ there exist unique
$q,r\in\N$ such that
\begin{equation}
  N = d q + r \quad\text{and}\quad 0 \le r < d,
  \label{eq:euclid}
\end{equation}
where $q = \left\lfloor N/d \right\rfloor$ and $r = N \bmod d$ \cite{euclid}.

\section{Settlement algebra}
\label{sec:settlement-algebra}

\subsection{Definition}

\begin{definition}[Settlement]
Define the \emph{settlement space} as
\[
  \mathsf{Settlement} \coloneqq \Z \times \Z.
\]
An element $s=(\Delta x,\Delta y)$ represents signed changes to two pool reserves.
Positive means \emph{inflow to the pool}, negative means \emph{outflow}.
\end{definition}

\begin{definition}[Composition and identity]
Define composition as componentwise addition:
\[
  (\Delta x_1,\Delta y_1) \circ_s (\Delta x_2,\Delta y_2)
  \coloneqq (\Delta x_1+\Delta x_2,\ \Delta y_1+\Delta y_2).
\]
The identity settlement is $0\coloneqq (0,0)$.
\end{definition}

\begin{proposition}[Abelian group structure]
$(\mathsf{Settlement}, \circ_s, 0)$ is an abelian group (indeed an $\mathsf{AddCommGroup}$ in Mathlib).
\end{proposition}
\begin{proof}
Componentwise integer addition is associative and commutative, with identity $(0,0)$ and inverse $-(\Delta x,\Delta y)=(-\Delta x,-\Delta y)$.
\end{proof}

\subsection{Net-flow homomorphism and balance}

\begin{definition}[Net scalar flow]
Define $\Delta : \mathsf{Settlement}\to\Z$ by
\[
  \Delta(\Delta x,\Delta y) \coloneqq \Delta x + \Delta y.
\]
\end{definition}

\begin{proposition}[Homomorphism]
$\Delta$ is a group homomorphism:
\[
  \Delta(s_1 \circ_s s_2) = \Delta(s_1) + \Delta(s_2), \qquad
  \Delta(0)=0,\qquad
  \Delta(-s) = -\Delta(s).
\]
\end{proposition}
\begin{proof}
Immediate from distributivity of addition in $\Z$:
\[
  \Delta((\Delta x_1+\Delta x_2,\Delta y_1+\Delta y_2))
  = (\Delta x_1+\Delta x_2)+(\Delta y_1+\Delta y_2)
  = (\Delta x_1+\Delta y_1) + (\Delta x_2+\Delta y_2).
\]
\end{proof}

\begin{definition}[Balanced settlements]
Call a settlement \emph{balanced} if $\Delta(s)=0$.
Equivalently,
\[
  \mathsf{Balanced} \coloneqq \ker(\Delta) \subseteq \mathsf{Settlement}.
\]
\end{definition}

\begin{proposition}[Kernel is a subgroup]
$\mathsf{Balanced}$ is an additive subgroup of $\mathsf{Settlement}$.
\end{proposition}
\begin{proof}
Kernels of homomorphisms are subgroups; explicitly:
if $\Delta(s_1)=0$ and $\Delta(s_2)=0$, then $\Delta(s_1\circ_s s_2)=0$,
and if $\Delta(s)=0$ then $\Delta(-s)=0$.
\end{proof}

\begin{remark}[``Safety'' as a scalar predicate]
The Lean development also defines a \emph{scalar safety} predicate
\[
  \mathsf{isSafe}(s) \iff \Delta(s) \ge 0.
\]
This is closed under composition by the homomorphism property and monotonicity of $+$ on $\Z$,
but it should not be conflated with economic safety, since it adds different token units.
\end{remark}

\subsection{Swap-to-settlement embedding}

\begin{definition}[Swap settlement]
Given natural amounts $\mathsf{amt}_{\mathrm{in}},\mathsf{amt}_{\mathrm{out}}\in\N$,
define the swap settlement (pool perspective)
\[
  \mathsf{swap}(\mathsf{amt}_{\mathrm{in}},\mathsf{amt}_{\mathrm{out}})
  \coloneqq (\mathsf{amt}_{\mathrm{in}},\ -\mathsf{amt}_{\mathrm{out}})\in\Z\times\Z.
\]
\end{definition}

Then
\[
  \Delta(\mathsf{swap}(\mathsf{amt}_{\mathrm{in}},\mathsf{amt}_{\mathrm{out}}))
  = \mathsf{amt}_{\mathrm{in}} - \mathsf{amt}_{\mathrm{out}}.
\]
In particular, if $\mathsf{amt}_{\mathrm{in}}=\mathsf{amt}_{\mathrm{out}}$ then the settlement is balanced.

\section{Batch optimality: maximizing volume and surplus}
\label{sec:batch-opt}

This section formalizes an objective for batch execution that is \emph{correctness-by-construction}:
invalid fills (output below minimum) are unrepresentable.

\subsection{Intents and valid outcomes}

\begin{definition}[Intent]
An \emph{intent} is a pair $i=(a,m)\in\N\times\N$, where $a$ is the input amount and $m$ is the minimum acceptable output.
\end{definition}

\begin{definition}[Valid outcome]
For a fixed intent $i=(a,m)$, a \emph{valid outcome} is either:
\begin{enumerate}[leftmargin=2em]
  \item \textsf{unfilled}, or
  \item \textsf{filled}$(o)$ for some $o\in\N$ with the proof obligation $o\ge m$.
\end{enumerate}
This is implemented as a dependent inductive type in Lean (\texttt{ValidOutcome i}).
\end{definition}

\subsection{Objective functions}

\begin{definition}[Volume and surplus]
For intent $i=(a,m)$ and valid outcome $o$:
\[
  \mathsf{volume}(o) \coloneqq
  \begin{cases}
    0 & \text{if unfilled}\\
    a & \text{if filled}
  \end{cases}
  \qquad
  \mathsf{surplus}(o) \coloneqq
  \begin{cases}
    0 & \text{if unfilled}\\
    o - m & \text{if filled with output }o\ge m.
  \end{cases}
\]
Because filled outcomes carry the proof $o\ge m$, the subtraction $o-m$ is well-defined in $\N$
(no underflow).
\end{definition}

\begin{definition}[$(A,B)$ pair]
Define the objective for a single intent/outcome as
\[
  \mathsf{AB}(o) \coloneqq (\mathsf{volume}(o),\ \mathsf{surplus}(o)) \in \N\times\N.
\]
For a batch (a finite list of intent/outcome pairs), define the batch score as componentwise sum:
\[
  \mathsf{AB}_{\mathrm{batch}} \coloneqq \sum_j \mathsf{AB}(o_j).
\]
In Lean this is \texttt{batchAB}, computed by a left fold with \texttt{pairAdd}.
\end{definition}

\subsection{Lexicographic comparison}

\begin{definition}[Lexicographic order]
For $p=(p_1,p_2),q=(q_1,q_2)\in\N\times\N$, define
\[
  p \preceq_{\mathrm{lex}} q \iff (p_1 < q_1)\ \lor\ (p_1=q_1 \land p_2 \le q_2),
\]
and strict order $p \prec_{\mathrm{lex}} q$ analogously with $p_2<q_2$.
\end{definition}

\begin{proposition}[Total preorder]
$\preceq_{\mathrm{lex}}$ is reflexive, transitive, and total on $\N\times\N$,
and the induced equivalence yields antisymmetry for $\preceq_{\mathrm{lex}}$ on pairs.
\end{proposition}
\begin{proof}
Standard case analysis on the first components; see Lean theorems:
\begin{itemize}[leftmargin=2em]
  \item \texttt{lexLe\_refl}
  \item \texttt{lexLe\_trans}
  \item \texttt{lexLe\_total}
  \item \texttt{lexLe\_antisymm}
\end{itemize}
\end{proof}

\section{CPMM model and invariants}
\label{sec:cpmm}

We model a constant-product pool with reserves $(x,y)\in\N^2$.

\subsection{Zero-fee swap semantics}

\begin{definition}[Zero-fee output]
Given reserves $(x,y)\in\N^2$ and input $a\in\N$, define the (zero-fee) output as
\begin{equation}
  q \coloneqq \left\lfloor \frac{y a}{x + a} \right\rfloor.
  \label{eq:cpmm-output}
\end{equation}
The updated reserves are
\begin{equation}
  x' \coloneqq x + a,\qquad
  y' \coloneqq y - q.
  \label{eq:cpmm-update}
\end{equation}
\end{definition}

\begin{lemma}[Output is reserve-bounded]
For all $x,y,a\in\N$, the output satisfies $q \le y$.
\end{lemma}
\begin{proof}
Since $a \le x+a$, we have $y a \le y(x+a)$. Dividing by the positive denominator $x+a$ gives
$\frac{y a}{x+a} \le y$, and taking floors yields $q \le y$.
\end{proof}

\subsection{The constant-product invariant and the \texorpdfstring{$K$}{K}-gap}

\begin{definition}[Constant product]
Define $K(x,y)\coloneqq x\cdot y$.
\end{definition}

\begin{theorem}[\texorpdfstring{$K$}{K}-monotonicity]
Under a zero-fee swap update \eqref{eq:cpmm-output}--\eqref{eq:cpmm-update}, the product never decreases:
\[
  K(x',y') \ge K(x,y).
\]
\end{theorem}
\begin{proof}[Proof (via the exact \texorpdfstring{$K$}{K}-gap identity)]
We strengthen the claim by showing the exact difference is a Euclidean remainder.
Let $d\coloneqq x+a$ and $N\coloneqq ya$.
By Euclidean division \eqref{eq:euclid}, there exist $q,r\in\N$ with $N=dq+r$ and $0\le r<d$.
By definition $q=\floor{N/d}=\floor{ya/(x+a)}$ which matches \eqref{eq:cpmm-output}.
Then:
\begin{align*}
  K(x',y') &= (x+a)\bigl(y - q\bigr) \\
           &= d y - d q \\
           &= d y - (N - r) \\
           &= (x+a)y - (ya) + r \\
           &= xy + r.
\end{align*}
Thus $K(x',y') - K(x,y)=r\ge 0$.
This is mechanized as \texttt{k\_gap\_exact} in \texttt{CPMMInvariants.lean}.
\end{proof}

\begin{definition}[\texorpdfstring{$K$}{K}-gap remainder]
Define the per-swap remainder (the \emph{$K$-gap}) as
\begin{equation}
  r(x,y,a) \coloneqq (y a) \bmod (x+a).
  \label{eq:k-gap}
\end{equation}
Then the exact $K$-gap identity is
\begin{equation}
  (x+a)\bigl(y - \floor{\tfrac{ya}{x+a}}\bigr) = xy + r(x,y,a).
  \label{eq:k-gap-exact}
\end{equation}
\end{definition}

\begin{corollary}[Characterizations]
For all $x,y,a\in\N$:
\begin{enumerate}[leftmargin=2em]
  \item $K(x',y')\ge K(x,y)$ (nonnegativity),
  \item $K(x',y') < K(x,y) + (x+a)$ (bounded increase, since $r<x+a$),
  \item $K(x',y') = K(x,y)$ iff $(x+a)\mid (ya)$ (zero remainder).
\end{enumerate}
\end{corollary}
\begin{proof}
Each follows from \eqref{eq:k-gap-exact} and standard properties of $\bmod$.
See \texttt{k\_gap\_nonneg}, \texttt{k\_gap\_bounded}, \texttt{k\_gap\_zero\_iff}.
\end{proof}

\subsection{Batches: telescoping the exact \texorpdfstring{$K$}{K}-gap}
\label{sec:batches}

\begin{definition}[Sequential execution]
Fix an initial state $(x_0,y_0)$ and a list of inputs $[a_1,\dots,a_n]$.
Define the sequence of states by iterating \eqref{eq:cpmm-output}--\eqref{eq:cpmm-update}:
$(x_{i},y_{i}) \mapsto (x_{i+1},y_{i+1})$ using input $a_{i+1}$.
\end{definition}

\begin{theorem}[Exact telescoping sum]
For the sequential execution above,
\begin{equation}
  K(x_n,y_n) = K(x_0,y_0) + \sum_{i=0}^{n-1} r(x_i,y_i,a_{i+1}),
  \label{eq:batch-k-gap-sum}
\end{equation}
where $r$ is the per-step remainder \eqref{eq:k-gap}.
\end{theorem}
\begin{proof}
Induction on $n$.
The induction step applies the single-step identity \eqref{eq:k-gap-exact} at state $(x_i,y_i)$
and accumulates remainders.
This is mechanized as \texttt{executeBatchSwaps\_K\_gap\_sum}.
\end{proof}

\begin{corollary}[Batch $K$-monotonicity]
Since each remainder is nonnegative, $K(x_n,y_n)\ge K(x_0,y_0)$ for every batch.
\end{corollary}

\section{Unification: settlements, objective, and CPMM state}
\label{sec:unification}

There are two complementary models for batch execution:
\begin{enumerate}[leftmargin=2em]
  \item \textbf{Intent/outcome (settlement \& objective) model.}
        A batch is a list of pairs (intent, valid outcome). It induces:
        (a) an aggregated settlement in $\mathsf{Settlement}$ (for $\Delta$-analysis) and
        (b) an aggregated objective score in $\N\times\N$ (for optimization).
  \item \textbf{State-transition (CPMM) model.}
        A batch is a list of inputs $[a_1,\dots,a_n]$ executed sequentially on reserves,
        yielding a final reserve state with verified $K$ properties.
\end{enumerate}

\subsection{Aggregating settlements}

For each intent/outcome pair, the Lean development defines a per-pair settlement:
unfilled contributes $0$, and filled contributes $\mathsf{swap}(a,o)$.
The batch settlement is the fold (sum) of these settlements.
Using the homomorphism property, scalar net-flow composes:
\[
  \Delta\Bigl(\sum_j s_j\Bigr) = \sum_j \Delta(s_j).
\]
Consequently, if each filled execution satisfies $a\ge o$ (a \emph{same-unit} condition),
then $\Delta$-safety composes over the batch (\texttt{batch\_safe\_implies\_settlement\_safe}).

\subsection{Refinement bridge and unified safety theorem}

The key bridge is that the output-generating function (computing $q_i$ sequentially)
reaches the same final state as the pure state-transition fold:
\[
  \mathsf{realizeBatchFinalState}(s,\vec a) = \mathsf{executeBatchSwaps}(s,\vec a).
\]
This is proved as \texttt{realizeBatch\_final\_state} in \texttt{BatchCPMMUnification.lean}.

As a consequence, the CPMM invariants proven for the state-transition model apply to the
same execution that feeds settlement/objective computations. The combined statement is
captured by \texttt{unified\_batch\_safety}, which simultaneously establishes:
\begin{enumerate}[leftmargin=2em]
  \item $K(\mathrm{final}) \ge K(\mathrm{initial})$,
  \item $K(\mathrm{final}) = K(\mathrm{initial}) + \sum \text{remainders}$ as in \eqref{eq:batch-k-gap-sum},
  \item reserve-in accounting: $x_{\mathrm{final}} = x_{\mathrm{initial}} + \sum_i a_i$.
\end{enumerate}

\section{Mechanization notes}
\label{sec:mechanization}

The results above are mechanized in Lean 4/Mathlib (no axioms and no \texttt{sorry}).
To typecheck/build the Lean project:
\begin{verbatim}
cd lean-mathlib
lake build
\end{verbatim}

\section{Limitations and future work}
\label{sec:future}

This development is deliberately minimal and focuses on arithmetic correctness and composition.
Several important directions remain:
\begin{itemize}[leftmargin=2em]
  \item Multi-asset generalization: settlements as $\Z^n$ vectors; richer notions of value conservation.
  \item Full batch clearing optimality: argmax existence over finite candidate sets and deterministic tie-breaking.
  \item Multi-hop routing and cross-pool execution: lifting $K$-style invariants across routing graphs.
  \item Overflow-aware models and byte-level constraints matching on-chain execution environments.
  \item Expanded fee models and protocol-specific mechanics (dynamic fees, rebates, TWAP/oracle guards, etc.).
\end{itemize}

\bibliographystyle{plain}
\bibliography{references}

\end{document}
