# Tokenomics Fee Split v1 - 32-bit safe variant
#
# MUTABILITY: UPDATABLE
# UPDATABLE_PARAMS: buyback_bps (i2), treasury_bps (i3), rewards_bps (i4)
# IMMUTABLE_INVARIANTS: shares sum to 10000, split math matches fee with rounding bounds
#
# PURPOSE: Validate externally-computed fee split into buyback/treasury/rewards buckets.
#
# Stream mapping:
# i1 = fee_amount (bv[32])
# i2 = buyback_share_bps (bv[32])
# i3 = treasury_share_bps (bv[32])
# i4 = rewards_share_bps (bv[32])
# i5 = buyback_amount (bv[32])
# i6 = treasury_amount (bv[32])
# i7 = rewards_amount (bv[32])
# o1 = share_bps_ok
# o2 = component_ok
# o3 = split_sum_ok
# o4 = fee_split_ok
# @rule o4: Shares sum, components match bps math, and rounding bounds pass.

set charvar off

# floor((2^32-1)/10000)
max_safe_32() := { #x00068DB8 }:bv[32].

shares_sum_ok(b1 : bv[32], b2 : bv[32], b3 : bv[32]) := (b1 + b2 + b3) = { #x00002710 }:bv[32].

# component = floor(fee * share / 10000) with tolerance
component_ok(fee : bv[32], share : bv[32], component : bv[32]) := (component * { #x00002710 }:bv[32] >= fee * share) && (component * { #x00002710 }:bv[32] <= (fee * share) + { #x0000270F }:bv[32]).

# At most 2 units total rounding loss across 3 components.
split_sum_ok(buyback : bv[32], treas : bv[32], rewards : bv[32], fee : bv[32]) := ((buyback + treas + rewards) <= fee) && ((buyback + treas + rewards + { #x00000002 }:bv[32]) >= fee).

safe_range_ok(fee : bv[32], buyback : bv[32], treas : bv[32], rewards : bv[32]) := (fee <= max_safe_32()) && (buyback <= max_safe_32()) && (treas <= max_safe_32()) && (rewards <= max_safe_32()).

always
  # @section: Share sum + per-component math
  (o1[t]:sbf = 1:sbf <-> shares_sum_ok(i2[t]:bv[32], i3[t]:bv[32], i4[t]:bv[32])) &&
  (o2[t]:sbf = 1:sbf <-> (component_ok(i1[t]:bv[32], i2[t]:bv[32], i5[t]:bv[32]) && component_ok(i1[t]:bv[32], i3[t]:bv[32], i6[t]:bv[32]) && component_ok(i1[t]:bv[32], i4[t]:bv[32], i7[t]:bv[32]))) &&
  # @section: Split sum + safe-range guard
  (o3[t]:sbf = 1:sbf <-> split_sum_ok(i5[t]:bv[32], i6[t]:bv[32], i7[t]:bv[32], i1[t]:bv[32])) &&
  (o4[t]:sbf = o1[t] & o2[t] & o3[t] & safe_range_ok(i1[t]:bv[32], i5[t]:bv[32], i6[t]:bv[32], i7[t]:bv[32])).
