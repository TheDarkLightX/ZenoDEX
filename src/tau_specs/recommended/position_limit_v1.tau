# Position Limit v1 - Maximum Position Size
#
# MUTABILITY: UPDATABLE
# UPDATABLE_PARAMS: max_position_bps (i3)
# IMMUTABLE_INVARIANTS: position_size <= pool_size * max_position_bps / 10000
#
# PURPOSE: Limit maximum position size as fraction of pool to prevent
# concentration risk and manipulation.
# No passive payouts - purely a risk management gate.
#
# DbC Preconditions:
# - All values are bv[32] (unsigned).
# - max_position_bps <= 2500 (25% max single position).
# - pool_size > 0.
#
# DbC Postcondition:
# - o4[t] = 1:sbf iff position within allowed fraction of pool.
#
# Stream mapping:
# i1 = position_size (bv[32]) - size of position being opened/modified
# i2 = pool_size (bv[32]) - total pool liquidity
# i3 = max_position_bps (bv[32]) - max position as bps of pool
# o1 = params_ok
# o2 = pool_ok
# o3 = position_within_limit
# o4 = position_ok
# @rule o4: Position size <= pool * max_bps / 10000.

set charvar off

# floor((2^32-1)/10000) for safe bps multiplication
max_safe_32() := { #x00068DB8 }:bv[32].

# Max position bps must be <= 2500 (25%)
rate_ok(rate : bv[32]) := rate <= { #x000009C4 }:bv[32].

# Pool size must be positive
pool_ok(pool : bv[32]) := pool > { #x00000000 }:bv[32].

# Safe range for multiplication
safe_range_ok(pool : bv[32], position : bv[32]) := (pool <= max_safe_32()) && (position <= max_safe_32()).

# Parameters valid
params_ok(pool : bv[32], position : bv[32], max_bps : bv[32]) := pool_ok(pool) && rate_ok(max_bps) && safe_range_ok(pool, position).

# Position check: position * 10000 <= pool * max_bps
position_within_limit(position : bv[32], pool : bv[32], max_bps : bv[32]) := (position * { #x00002710 }:bv[32]) <= (pool * max_bps).

# Full position check
position_valid(position : bv[32], pool : bv[32], max_bps : bv[32]) := params_ok(pool, position, max_bps) && position_within_limit(position, pool, max_bps).

always
  # @section: Parameter validation
  (o1[t]:sbf = 1:sbf <-> params_ok(i2[t]:bv[32], i1[t]:bv[32], i3[t]:bv[32])) &&
  # @section: Pool check
  (o2[t]:sbf = 1:sbf <-> pool_ok(i2[t]:bv[32])) &&
  # @section: Position limit check
  (o3[t]:sbf = 1:sbf <-> position_within_limit(i1[t]:bv[32], i2[t]:bv[32], i3[t]:bv[32])) &&
  # @section: Aggregated position validity
  (o4[t]:sbf = 1:sbf <-> position_valid(i1[t]:bv[32], i2[t]:bv[32], i3[t]:bv[32])).
