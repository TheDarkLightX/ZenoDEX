#
# Protocol token v3 (Tau-executable, bv[16] / sbf)
#
# Motivation:
# - Some Tau builds have been observed to crash (rc=-11) on bv[32]-heavy token
#   transition constraints in REPL harness mode.
# - For trace-level verification (and for the v4-safe-range posture), we keep
#   all amounts bounded to u16 and use bv[16] directly.
#
# Stream mapping:
# i1 = from_before (bv[16])
# i2 = to_before (bv[16])
# i3 = supply_before (bv[16])
# i4 = amount (bv[16])
# i5 = from_after (bv[16])
# i6 = to_after (bv[16])
# i7 = supply_after (bv[16])
# i8 = do_transfer (sbf)
# i9 = do_mint (sbf)
# i10 = do_burn (sbf)
# o1 = token_transition_valid
#

set charvar off

one_hot_3(a : sbf, b : sbf, c : sbf) :=
  ((a = 1:sbf) && (b = 0:sbf) && (c = 0:sbf)) ||
  ((a = 0:sbf) && (b = 1:sbf) && (c = 0:sbf)) ||
  ((a = 0:sbf) && (b = 0:sbf) && (c = 1:sbf)).

always
  (o1[t]:sbf = 1:sbf <->
    (
      one_hot_3(i8[t]:sbf, i9[t]:sbf, i10[t]:sbf) &&
      (i4[t]:bv[16] > { #x0000 }:bv[16]) &&

      # Transfer (if selected)
      ((i8[t]:sbf = 0:sbf) ||
        (
          (i1[t]:bv[16] >= i4[t]:bv[16]) &&
          (i5[t]:bv[16] = (i1[t]:bv[16] - i4[t]:bv[16])) &&
          (i6[t]:bv[16] = (i2[t]:bv[16] + i4[t]:bv[16])) &&
          (i7[t]:bv[16] = i3[t]:bv[16])
        )
      ) &&

      # Mint (if selected)
      ((i9[t]:sbf = 0:sbf) ||
        (
          (i5[t]:bv[16] = i1[t]:bv[16]) &&
          (i6[t]:bv[16] = (i2[t]:bv[16] + i4[t]:bv[16])) &&
          (i7[t]:bv[16] = (i3[t]:bv[16] + i4[t]:bv[16]))
        )
      ) &&

      # Burn (if selected)
      ((i10[t]:sbf = 0:sbf) ||
        (
          (i1[t]:bv[16] >= i4[t]:bv[16]) &&
          (i3[t]:bv[16] >= i4[t]:bv[16]) &&
          (i5[t]:bv[16] = (i1[t]:bv[16] - i4[t]:bv[16])) &&
          (i6[t]:bv[16] = i2[t]:bv[16]) &&
          (i7[t]:bv[16] = (i3[t]:bv[16] - i4[t]:bv[16]))
        )
      )
    )
  ).

