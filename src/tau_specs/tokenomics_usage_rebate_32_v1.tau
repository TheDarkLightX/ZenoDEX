# Tokenomics Usage-Rebate v1 - 32-bit safe variant
#
# MUTABILITY: UPDATABLE
# UPDATABLE_PARAMS: rebate_rate_bps (i3), rebate_cap (i6), min_usage (i2)
# IMMUTABLE_INVARIANTS: rebate only when usage >= min, rebate <= cap, bps math
#
# PURPOSE: Ensure rebates are tied to actual usage, not passive holding.
#
# Stream mapping:
# i1 = fee_amount (bv[32])
# i2 = min_usage (bv[32])
# i3 = rebate_rate_bps (bv[32])
# i4 = usage_score (bv[32])
# i5 = rebate_amount (bv[32])
# i6 = rebate_cap (bv[32])
# o1 = usage_ok
# o2 = rebate_math_ok
# o3 = cap_ok
# o4 = usage_rebate_ok
# @rule o4: Usage gate, bps math, and rebate cap all pass.

set charvar off

# max_safe_32 = floor((2^32-1)/10000) = 0x00068DB8

rate_ok(rate : bv[32]) := rate <= { #x00002710 }:bv[32].

usage_ok(score : bv[32], min : bv[32], rebate : bv[32]) := (score >= min) && (rebate <= score).

# rebate = floor(fee * rate / 10000) with rounding tolerance
rebate_calc_ok(fee : bv[32], rate : bv[32], rebate : bv[32]) := (rebate * { #x00002710 }:bv[32] >= fee * rate) && (rebate * { #x00002710 }:bv[32] <= (fee * rate) + { #x0000270F }:bv[32]).

cap_ok(rebate : bv[32], cap : bv[32]) := rebate <= cap.

safe_range_ok(fee : bv[32], rebate : bv[32]) := (fee <= { #x00068DB8 }:bv[32]) && (rebate <= { #x00068DB8 }:bv[32]).

always
  # @section: Usage gate
  (o1[t]:sbf = 1:sbf <-> usage_ok(i4[t]:bv[32], i2[t]:bv[32], i5[t]:bv[32])) &&
  # @section: Rebate math + caps
  (o2[t]:sbf = 1:sbf <-> (rate_ok(i3[t]:bv[32]) && rebate_calc_ok(i1[t]:bv[32], i3[t]:bv[32], i5[t]:bv[32]))) &&
  (o3[t]:sbf = 1:sbf <-> cap_ok(i5[t]:bv[32], i6[t]:bv[32])) &&
  # @section: Full module check (includes safe-range guard)
  # FIX: Changed from bitwise & to logical && with biconditional
  (o4[t]:sbf = 1:sbf <-> (o1[t]:sbf = 1:sbf) && (o2[t]:sbf = 1:sbf) && (o3[t]:sbf = 1:sbf) && safe_range_ok(i1[t]:bv[32], i5[t]:bv[32])).
