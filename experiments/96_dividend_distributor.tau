# Spec 96: Dividend and Rebate Distribution Validator
# NOVEL: Validates fair pro-rata dividend distribution to holders
# Ensures distributions are proportional to holdings
# Prevents distribution gaming and front-running
#
# Inputs: i1 = user_balance, i2 = total_supply, i3 = dividend_pool,
#         i4 = user_dividend, i5 = snapshot_block
# Outputs: o1 = share_correct, o2 = no_dilution, o3 = distribution_fair, o4 = snapshot_valid

# Share correct: user_dividend = dividend_pool * user_balance / total_supply
# Cross-mult: user_dividend * total_supply <= dividend_pool * user_balance + total_supply
sharecorrect(userbal : bv[16], totalsupply : bv[16], divpool : bv[16], userdiv : bv[16]) := (totalsupply > { #x0000 }:bv[16]) && (userdiv * totalsupply <= divpool * userbal + totalsupply).

# No dilution: user's share of dividends >= their share of supply
nodilution(userbal : bv[16], totalsupply : bv[16], userdiv : bv[16], divpool : bv[16]) := (totalsupply > { #x0000 }:bv[16}) && (divpool > { #x0000 }:bv[16]) && (userdiv * totalsupply >= userbal * divpool - totalsupply).

# Distribution fair: share is correct within tolerance
distributionfair(userbal : bv[16], totalsupply : bv[16], divpool : bv[16], userdiv : bv[16]) := sharecorrect(userbal, totalsupply, divpool, userdiv).

# Snapshot valid: balance didn't change since snapshot (prevents front-running)
snapshotvalid(currbal : bv[16], prevbal : bv[16]) := currbal = prevbal.

always (o1[0]:sbf = 0:sbf) && (o2[0]:sbf = 0:sbf) && (o3[0]:sbf = 0:sbf) && (o4[0]:sbf = 0:sbf) && (o1[t]:sbf = 1:sbf <-> sharecorrect(i1[t]:bv[16], i2[t]:bv[16], i3[t]:bv[16], i4[t]:bv[16])) && (o2[t]:sbf = 1:sbf <-> nodilution(i1[t]:bv[16], i2[t]:bv[16], i4[t]:bv[16], i3[t]:bv[16])) && (o3[t]:sbf = 1:sbf <-> distributionfair(i1[t]:bv[16], i2[t]:bv[16], i3[t]:bv[16], i4[t]:bv[16])) && (o4[t]:sbf = 1:sbf <-> snapshotvalid(i1[t]:bv[16], i1[t-1]:bv[16])).
