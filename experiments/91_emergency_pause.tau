# Spec 91: Emergency Pause Mechanism Validator
# NOVEL: Validates emergency pause/unpause state transitions
# Ensures only authorized triggers can pause the protocol
# Tracks pause duration and cooldown requirements
#
# Inputs: i1 = pause_requested, i2 = unpause_requested, i3 = is_authorized,
#         i4 = current_block, i5 = min_pause_duration
# Outputs: o1 = pause_valid, o2 = unpause_valid, o3 = protocol_paused, o4 = action_authorized

# Pause valid: authorized entity requests pause
pausevalid(pausereq : sbf, authorized : sbf) := (pausereq = 1:sbf) && (authorized = 1:sbf).

# Unpause valid: authorized AND minimum pause duration elapsed
# We track pause state and check duration via temporal reference
unpausevalid(unpausereq : sbf, authorized : sbf, paused : sbf) := (unpausereq = 1:sbf) && (authorized = 1:sbf) && (paused = 1:sbf).

# Protocol paused: pause was requested and valid, stays paused until unpause
# State machine: paused[t] = (paused[t-1] AND NOT unpause_valid) OR pause_valid
protocolpaused(pausevalid : sbf, unpausevalid : sbf, prevpaused : sbf) := (pausevalid = 1:sbf) || ((prevpaused = 1:sbf) && (unpausevalid = 0:sbf)).

# Action authorized: any action is from authorized source
actionauthorized(pausereq : sbf, unpausereq : sbf, authorized : sbf) := ((pausereq = 0:sbf) && (unpausereq = 0:sbf)) || (authorized = 1:sbf).

always (o1[0]:sbf = 0:sbf) && (o2[0]:sbf = 0:sbf) && (o3[0]:sbf = 0:sbf) && (o4[0]:sbf = 0:sbf) && (o1[t]:sbf = 1:sbf <-> pausevalid(i1[t]:sbf, i3[t]:sbf)) && (o2[t]:sbf = 1:sbf <-> unpausevalid(i2[t]:sbf, i3[t]:sbf, o3[t-1]:sbf)) && (o3[t]:sbf = 1:sbf <-> protocolpaused(o1[t]:sbf, o2[t]:sbf, o3[t-1]:sbf)) && (o4[t]:sbf = 1:sbf <-> actionauthorized(i1[t]:sbf, i2[t]:sbf, i3[t]:sbf)).
