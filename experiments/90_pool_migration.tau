# Spec 90: Pool Migration Safety Validator
# NOVEL: Validates safe migration of liquidity between pool versions
# Ensures no value leakage during migration process
# Tracks migration state and completion
#
# Inputs: i1 = old_pool_balance, i2 = new_pool_balance, i3 = migration_amount,
#         i4 = migration_started, i5 = migration_complete
# Outputs: o1 = balance_conserved, o2 = migration_valid, o3 = no_leakage, o4 = migration_safe

# Balance conserved: old_pool decrease = new_pool increase
# old_balance[t-1] - old_balance[t] = new_balance[t] - new_balance[t-1]
balanceconserved(oldcurr : bv[16], oldprev : bv[16], newcurr : bv[16], newprev : bv[16]) := (oldprev >= oldcurr) && (newcurr >= newprev) && ((oldprev - oldcurr) = (newcurr - newprev)).

# Migration valid: amount moved matches migration_amount
migrationvalid(oldcurr : bv[16], oldprev : bv[16], migamt : bv[16]) := (oldprev >= oldcurr) && ((oldprev - oldcurr) = migamt).

# No leakage: total value (old + new) is constant
noleakage(oldcurr : bv[16], newcurr : bv[16], oldprev : bv[16], newprev : bv[16]) := oldcurr + newcurr = oldprev + newprev.

# Migration safe: all conditions met
migrationsafe(oldcurr : bv[16], oldprev : bv[16], newcurr : bv[16], newprev : bv[16], migamt : bv[16]) := balanceconserved(oldcurr, oldprev, newcurr, newprev) && noleakage(oldcurr, newcurr, oldprev, newprev).

always (o1[0]:sbf = 0:sbf) && (o2[0]:sbf = 0:sbf) && (o3[0]:sbf = 0:sbf) && (o4[0]:sbf = 0:sbf) && (o1[t]:sbf = 1:sbf <-> balanceconserved(i1[t]:bv[16], i1[t-1]:bv[16], i2[t]:bv[16], i2[t-1]:bv[16])) && (o2[t]:sbf = 1:sbf <-> migrationvalid(i1[t]:bv[16], i1[t-1]:bv[16], i3[t]:bv[16])) && (o3[t]:sbf = 1:sbf <-> noleakage(i1[t]:bv[16], i2[t]:bv[16], i1[t-1]:bv[16], i2[t-1]:bv[16])) && (o4[t]:sbf = 1:sbf <-> migrationsafe(i1[t]:bv[16], i1[t-1]:bv[16], i2[t]:bv[16], i2[t-1]:bv[16], i3[t]:bv[16])).
