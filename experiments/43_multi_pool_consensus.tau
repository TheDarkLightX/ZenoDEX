# Spec 43: Multi-Pool Byzantine Fault Tolerant Price Consensus
# NOVEL: Implements BFT-style consensus across 5 price sources
# Tolerates up to 2 faulty/malicious oracles (5 = 3f+2, f=1 with margin)
# Uses voting and outlier detection rather than simple median
#
# Inputs: i1-i5 = five independent price sources
# Outputs: o1 = consensus_reached, o2 = outlier_detected, o3 = price_valid, 
#          o4 = attack_likely (multiple outliers)

# Agreement check: two prices within 2% of each other
agree(a : bv[16], b : bv[16]) := ((a >= b) && ((a - b) * { #x0064 }:bv[16] < b * { #x0002 }:bv[16])) || ((a < b) && ((b - a) * { #x0064 }:bv[16] < a * { #x0002 }:bv[16])).

# Count agreements for price p1 with others (simplified: check if 3+ agree)
# BFT requires 2f+1 = 3 agreements for f=1 fault tolerance
hasquorum(p1 : bv[16], p2 : bv[16], p3 : bv[16], p4 : bv[16], p5 : bv[16]) := (agree(p1, p2) && agree(p1, p3)) || (agree(p1, p2) && agree(p1, p4)) || (agree(p1, p2) && agree(p1, p5)) || (agree(p1, p3) && agree(p1, p4)) || (agree(p1, p3) && agree(p1, p5)) || (agree(p1, p4) && agree(p1, p5)).

# Consensus exists if any price has quorum support
consensus(p1 : bv[16], p2 : bv[16], p3 : bv[16], p4 : bv[16], p5 : bv[16]) := hasquorum(p1, p2, p3, p4, p5) || hasquorum(p2, p1, p3, p4, p5) || hasquorum(p3, p1, p2, p4, p5) || hasquorum(p4, p1, p2, p3, p5) || hasquorum(p5, p1, p2, p3, p4).

# Outlier detection: price differs from all others by > 5%
isoutlier(p : bv[16], p2 : bv[16], p3 : bv[16], p4 : bv[16], p5 : bv[16]) := !agree(p, p2) && !agree(p, p3) && !agree(p, p4) && !agree(p, p5).

# Any outlier exists
outlierexists(p1 : bv[16], p2 : bv[16], p3 : bv[16], p4 : bv[16], p5 : bv[16]) := isoutlier(p1, p2, p3, p4, p5) || isoutlier(p2, p1, p3, p4, p5) || isoutlier(p3, p1, p2, p4, p5) || isoutlier(p4, p1, p2, p3, p5) || isoutlier(p5, p1, p2, p3, p4).

# Attack likely: 2+ outliers (coordinated manipulation attempt)
multioutlier(p1 : bv[16], p2 : bv[16], p3 : bv[16], p4 : bv[16], p5 : bv[16]) := (isoutlier(p1, p2, p3, p4, p5) && isoutlier(p2, p1, p3, p4, p5)) || (isoutlier(p1, p2, p3, p4, p5) && isoutlier(p3, p1, p2, p4, p5)) || (isoutlier(p1, p2, p3, p4, p5) && isoutlier(p4, p1, p2, p3, p5)) || (isoutlier(p1, p2, p3, p4, p5) && isoutlier(p5, p1, p2, p3, p4)) || (isoutlier(p2, p1, p3, p4, p5) && isoutlier(p3, p1, p2, p4, p5)) || (isoutlier(p2, p1, p3, p4, p5) && isoutlier(p4, p1, p2, p3, p5)) || (isoutlier(p2, p1, p3, p4, p5) && isoutlier(p5, p1, p2, p3, p4)) || (isoutlier(p3, p1, p2, p4, p5) && isoutlier(p4, p1, p2, p3, p5)) || (isoutlier(p3, p1, p2, p4, p5) && isoutlier(p5, p1, p2, p3, p4)) || (isoutlier(p4, p1, p2, p3, p5) && isoutlier(p5, p1, p2, p3, p4)).

# Price valid only if consensus and no attack
pricevalid(p1 : bv[16], p2 : bv[16], p3 : bv[16], p4 : bv[16], p5 : bv[16]) := consensus(p1, p2, p3, p4, p5) && !multioutlier(p1, p2, p3, p4, p5).

always (o1[t]:sbf = 1:sbf <-> consensus(i1[t]:bv[16], i2[t]:bv[16], i3[t]:bv[16], i4[t]:bv[16], i5[t]:bv[16])) && (o2[t]:sbf = 1:sbf <-> outlierexists(i1[t]:bv[16], i2[t]:bv[16], i3[t]:bv[16], i4[t]:bv[16], i5[t]:bv[16])) && (o3[t]:sbf = 1:sbf <-> pricevalid(i1[t]:bv[16], i2[t]:bv[16], i3[t]:bv[16], i4[t]:bv[16], i5[t]:bv[16])) && (o4[t]:sbf = 1:sbf <-> multioutlier(i1[t]:bv[16], i2[t]:bv[16], i3[t]:bv[16], i4[t]:bv[16], i5[t]:bv[16])).
