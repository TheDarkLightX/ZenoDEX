# Spec 64: Governance Timelock Validator
# NOVEL: Validates governance actions follow required timelock delays
# Ensures proposals execute only after minimum delay period
# Prevents rushed governance attacks
#
# Inputs: i1 = proposal_timestamp, i2 = current_timestamp, i3 = min_delay,
#         i4 = execution_requested
# Outputs: o1 = delay_elapsed, o2 = execution_valid, o3 = proposal_mature, o4 = governance_safe

# Delay elapsed: current_time - proposal_time >= min_delay
delayelapsed(proposalts : bv[16], currentts : bv[16], mindelay : bv[16]) := (currentts >= proposalts) && ((currentts - proposalts) >= mindelay).

# Execution valid: delay elapsed AND execution was requested
executionvalid(proposalts : bv[16], currentts : bv[16], mindelay : bv[16], execreq : sbf) := delayelapsed(proposalts, currentts, mindelay) && (execreq = 1:sbf).

# Proposal mature: past minimum delay, ready for execution
proposalmature(proposalts : bv[16], currentts : bv[16], mindelay : bv[16]) := delayelapsed(proposalts, currentts, mindelay).

# Governance safe: no premature execution attempts
# If execution requested but delay not elapsed, governance is unsafe
governancesafe(proposalts : bv[16], currentts : bv[16], mindelay : bv[16], execreq : sbf) := (execreq = 0:sbf) || delayelapsed(proposalts, currentts, mindelay).

always (o1[0]:sbf = 0:sbf) && (o2[0]:sbf = 0:sbf) && (o3[0]:sbf = 0:sbf) && (o4[0]:sbf = 0:sbf) && (o1[t]:sbf = 1:sbf <-> delayelapsed(i1[t]:bv[16], i2[t]:bv[16], i3[t]:bv[16])) && (o2[t]:sbf = 1:sbf <-> executionvalid(i1[t]:bv[16], i2[t]:bv[16], i3[t]:bv[16], i4[t]:sbf)) && (o3[t]:sbf = 1:sbf <-> proposalmature(i1[t]:bv[16], i2[t]:bv[16], i3[t]:bv[16])) && (o4[t]:sbf = 1:sbf <-> governancesafe(i1[t]:bv[16], i2[t]:bv[16], i3[t]:bv[16], i4[t]:sbf)).
