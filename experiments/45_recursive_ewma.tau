# Spec 45: Recursive Exponential Weighted Moving Average State Machine
# NOVEL: True recursive accumulator using temporal output-to-input feedback
# Implements EWMA: ewma[t] = alpha * price[t] + (1-alpha) * ewma[t-1]
# Alpha = 1/4 (25%), so: ewma[t] = price[t]/4 + 3*ewma[t-1]/4
# Uses bitvector shifts for efficient division by powers of 2
#
# Inputs: i1 = current_price
# Outputs: o1 = ewma_value (bv[16]), o2 = price_above_ewma, o3 = trend_bullish

# EWMA computation using bit shifts (divide by 4 = shift right 2)
# ewma[t] = (price >> 2) + ewma[t-1] - (ewma[t-1] >> 2)
# This is: price/4 + ewma - ewma/4 = price/4 + 3*ewma/4

# Trend bullish: price has been above EWMA for 3 consecutive steps
trendbullish(above0 : sbf, above1 : sbf, above2 : sbf) := (above0 = 1:sbf) && (above1 = 1:sbf) && (above2 = 1:sbf).

# Trend bearish: price has been below EWMA for 3 consecutive steps
trendbearish(above0 : sbf, above1 : sbf, above2 : sbf) := (above0 = 0:sbf) && (above1 = 0:sbf) && (above2 = 0:sbf).

# Crossover detection: price crossed EWMA this step
crossover(above0 : sbf, above1 : sbf) := (above0 = 1:sbf && above1 = 0:sbf) || (above0 = 0:sbf && above1 = 1:sbf).

# Initialize EWMA to first price, then update recursively
# o1[t] = price[t]/4 + o1[t-1]*3/4
# Using shifts: o1[t] = (i1[t] >> 2) + o1[t-1] - (o1[t-1] >> 2)

always (o1[0]:bv[16] = i1[0]:bv[16]) && (o1[1]:bv[16] = (i1[1]:bv[16] >> { 2 }:bv[16]) + o1[0]:bv[16] - (o1[0]:bv[16] >> { 2 }:bv[16])) && (o2[0]:sbf = 0:sbf) && (o2[1]:sbf = 0:sbf) && (o3[0]:sbf = 0:sbf) && (o3[1]:sbf = 0:sbf) && (o4[0]:sbf = 0:sbf) && (o4[1]:sbf = 0:sbf) && (o5[0]:sbf = 0:sbf) && (o5[1]:sbf = 0:sbf) && (o1[t]:bv[16] = (i1[t]:bv[16] >> { 2 }:bv[16]) + o1[t-1]:bv[16] - (o1[t-1]:bv[16] >> { 2 }:bv[16])) && (o2[t]:sbf = 1:sbf <-> i1[t]:bv[16] > o1[t]:bv[16]) && (o3[t]:sbf = 1:sbf <-> trendbullish(o2[t]:sbf, o2[t-1]:sbf, o2[t-2]:sbf)) && (o4[t]:sbf = 1:sbf <-> trendbearish(o2[t]:sbf, o2[t-1]:sbf, o2[t-2]:sbf)) && (o5[t]:sbf = 1:sbf <-> crossover(o2[t]:sbf, o2[t-1]:sbf)).
