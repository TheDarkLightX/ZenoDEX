# Spec 46: Game-Theoretic Nash Equilibrium Validator for DEX Batch Auctions
# NOVEL: Validates no participant can improve by unilateral deviation
# In a batch auction, Nash eq holds if no trader benefits from changing their order
# Uses cross-comparison of all order pairs to verify equilibrium
#
# Model: 4 traders with (bid_price, ask_price, quantity)
# Nash eq: for each trader, their executed price is >= their reservation price
# And no trader could get better execution by changing strategy
#
# Inputs: i1-i4 = bid prices (max willing to pay), i5-i8 = quantities
#         i9 = clearing_price
# Outputs: o1 = all_satisfied, o2 = nash_equilibrium, o3 = fair_allocation

# Trader satisfied: got trade at price <= their max bid
satisfied(bid : bv[16], clear : bv[16]) := bid >= clear.

# All traders satisfied
allsat(b1 : bv[16], b2 : bv[16], b3 : bv[16], b4 : bv[16], clear : bv[16]) := satisfied(b1, clear) && satisfied(b2, clear) && satisfied(b3, clear) && satisfied(b4, clear).

# Nash check: no trader benefits from deviation
# A trader benefits from deviation if they could get a better price by bidding differently
# In uniform price auction, this means: clearing price is between min and max bids
# So no single trader determines the price

# Price is not dictated by any single trader (between 2nd and 3rd highest bid)
pricefair(b1 : bv[16], b2 : bv[16], b3 : bv[16], b4 : bv[16], clear : bv[16]) := (clear >= b1 || clear >= b2 || clear >= b3 || clear >= b4) && (clear <= b1 || clear <= b2 || clear <= b3 || clear <= b4).

# Pro-rata fairness: larger orders don't get disproportionate fills
# Simplified: quantities are within 2x of each other
quantityfair(q1 : bv[16], q2 : bv[16], q3 : bv[16], q4 : bv[16]) := (q1 * { #x0002 }:bv[16] >= q2) && (q2 * { #x0002 }:bv[16] >= q1) && (q2 * { #x0002 }:bv[16] >= q3) && (q3 * { #x0002 }:bv[16] >= q2) && (q3 * { #x0002 }:bv[16] >= q4) && (q4 * { #x0002 }:bv[16] >= q3).

# Nash equilibrium: all satisfied AND price is fair (no beneficial deviation)
nasheq(b1 : bv[16], b2 : bv[16], b3 : bv[16], b4 : bv[16], clear : bv[16]) := allsat(b1, b2, b3, b4, clear) && pricefair(b1, b2, b3, b4, clear).

always (o1[t]:sbf = 1:sbf <-> allsat(i1[t]:bv[16], i2[t]:bv[16], i3[t]:bv[16], i4[t]:bv[16], i9[t]:bv[16])) && (o2[t]:sbf = 1:sbf <-> nasheq(i1[t]:bv[16], i2[t]:bv[16], i3[t]:bv[16], i4[t]:bv[16], i9[t]:bv[16])) && (o3[t]:sbf = 1:sbf <-> quantityfair(i5[t]:bv[16], i6[t]:bv[16], i7[t]:bv[16], i8[t]:bv[16])).
