"""
Auto-generated Python reference model for: vault_manager
IR hash: sha256:2b27f6088aaf33c6c75d07572dfdd8df6ef3c82d947af294c2620d99aea543bb

Generated by an offline verifier toolchain.

This file is standalone and has no toolchain dependencies.
"""

from __future__ import annotations

from dataclasses import dataclass
from typing import Any, Literal, Mapping


@dataclass(frozen=True)
class State:
    """Model state."""
    acc_reward_per_share: int
    last_update_acc: int
    pending_rewards: int
    reward_balance: int
    staked_lp_shares: int


@dataclass(frozen=True)
class Command:
    """Command to execute."""
    tag: Literal('deposit_rewards', 'harvest', 'stake', 'unstake')
    args: Mapping[str, Any]


@dataclass(frozen=True)
class StepResult:
    """Result of a step execution."""
    ok: bool
    state: State | None = None
    effects: Mapping[str, Any] | None = None
    error: str | None = None


def init_state() -> State:
    """Return the initial state."""
    return State(
        acc_reward_per_share=0,
        last_update_acc=0,
        pending_rewards=0,
        reward_balance=0,
        staked_lp_shares=0,
    )


def check_invariants(s: State) -> tuple[bool, str | None]:
    """Check all invariants. Returns (ok, first_failed_id)."""
    if not (isinstance(s.acc_reward_per_share, int) and not isinstance(s.acc_reward_per_share, bool) and 0 <= s.acc_reward_per_share <= 1000000000000):
        return False, 'domain_acc_reward_per_share'
    if not (isinstance(s.last_update_acc, int) and not isinstance(s.last_update_acc, bool) and 0 <= s.last_update_acc <= 1000000000000):
        return False, 'domain_last_update_acc'
    if not (isinstance(s.pending_rewards, int) and not isinstance(s.pending_rewards, bool) and 0 <= s.pending_rewards <= 1000000):
        return False, 'domain_pending_rewards'
    if not (isinstance(s.reward_balance, int) and not isinstance(s.reward_balance, bool) and 0 <= s.reward_balance <= 1000000):
        return False, 'domain_reward_balance'
    if not (isinstance(s.staked_lp_shares, int) and not isinstance(s.staked_lp_shares, bool) and 0 <= s.staked_lp_shares <= 100):
        return False, 'domain_staked_lp_shares'
    if not ((s.acc_reward_per_share >= s.last_update_acc)):
        return False, 'inv_acc_reward_per_share_monotone'
    if not ((s.pending_rewards <= s.reward_balance)):
        return False, 'inv_pending_le_reward_balance'
    if not ((s.pending_rewards >= 0)):
        return False, 'inv_pending_rewards_nonnegative'
    if not ((s.reward_balance >= 0)):
        return False, 'inv_reward_balance_nonnegative'
    if not ((s.staked_lp_shares >= 0)):
        return False, 'inv_staked_lp_shares_nonnegative'
    return True, None


def step(s: State, cmd: Command) -> StepResult:
    """Execute a step. Returns StepResult."""
    # Check pre-state invariants
    ok, failed = check_invariants(s)
    if not ok:
        return StepResult(ok=False, error=f'pre-invariant violated: {failed}')

    if cmd.tag == 'deposit_rewards':
        if 'amount' not in cmd.args or not (isinstance(cmd.args['amount'], int) and not isinstance(cmd.args['amount'], bool) and 1 <= cmd.args['amount'] <= 10000):
            return StepResult(ok=False, error='invalid param amount')
        if not (((((cmd.args['amount'] + s.pending_rewards) <= 1000000) if (0 == s.staked_lp_shares) else (((0 if s.staked_lp_shares == 0 else (((1000000 * (cmd.args['amount'] + s.pending_rewards)) // s.staked_lp_shares) + (1 if ((1000000 * (cmd.args['amount'] + s.pending_rewards)) % s.staked_lp_shares) < 0 else 0))) + s.acc_reward_per_share) <= 1000000000000)) and ((cmd.args['amount'] + s.reward_balance) <= 1000000))):
            return StepResult(ok=False, error='guard failed for deposit_rewards')
        # Compute updates (simultaneous)
        new_state = State(
            acc_reward_per_share=((0 if (0 == s.staked_lp_shares) else (0 if s.staked_lp_shares == 0 else (((1000000 * (cmd.args['amount'] + s.pending_rewards)) // s.staked_lp_shares) + (1 if ((1000000 * (cmd.args['amount'] + s.pending_rewards)) % s.staked_lp_shares) < 0 else 0)))) + s.acc_reward_per_share),
            last_update_acc=s.acc_reward_per_share,
            pending_rewards=((cmd.args['amount'] + s.pending_rewards) if (0 == s.staked_lp_shares) else ((cmd.args['amount'] + s.pending_rewards) - (0 if 1000000 == 0 else ((((0 if s.staked_lp_shares == 0 else (((1000000 * (cmd.args['amount'] + s.pending_rewards)) // s.staked_lp_shares) + (1 if ((1000000 * (cmd.args['amount'] + s.pending_rewards)) % s.staked_lp_shares) < 0 else 0))) * s.staked_lp_shares) // 1000000) + (1 if (((0 if s.staked_lp_shares == 0 else (((1000000 * (cmd.args['amount'] + s.pending_rewards)) // s.staked_lp_shares) + (1 if ((1000000 * (cmd.args['amount'] + s.pending_rewards)) % s.staked_lp_shares) < 0 else 0))) * s.staked_lp_shares) % 1000000) < 0 else 0))))),
            reward_balance=(cmd.args['amount'] + s.reward_balance),
            staked_lp_shares=s.staked_lp_shares,
        )
        effects = {
            'delta_acc': (new_state.acc_reward_per_share - new_state.last_update_acc),
            'harvested_reward': 0,
        }
        ok, failed = check_invariants(new_state)
        if not ok:
            return StepResult(ok=False, error=f'post-invariant violated: {failed}')
        return StepResult(ok=True, state=new_state, effects=effects)
    elif cmd.tag == 'harvest':
        if 'entry_acc' not in cmd.args or not (isinstance(cmd.args['entry_acc'], int) and not isinstance(cmd.args['entry_acc'], bool) and 0 <= cmd.args['entry_acc'] <= 1000000000000):
            return StepResult(ok=False, error='invalid param entry_acc')
        if not ((((0 if 1000000 == 0 else ((((s.acc_reward_per_share - cmd.args['entry_acc']) * s.staked_lp_shares) // 1000000) + (1 if (((s.acc_reward_per_share - cmd.args['entry_acc']) * s.staked_lp_shares) % 1000000) < 0 else 0))) <= (s.reward_balance - s.pending_rewards)) and (cmd.args['entry_acc'] <= s.acc_reward_per_share))):
            return StepResult(ok=False, error='guard failed for harvest')
        # Compute updates (simultaneous)
        new_state = State(
            acc_reward_per_share=s.acc_reward_per_share,
            last_update_acc=s.acc_reward_per_share,
            pending_rewards=s.pending_rewards,
            reward_balance=(s.reward_balance - (0 if 1000000 == 0 else ((((s.acc_reward_per_share - cmd.args['entry_acc']) * s.staked_lp_shares) // 1000000) + (1 if (((s.acc_reward_per_share - cmd.args['entry_acc']) * s.staked_lp_shares) % 1000000) < 0 else 0)))),
            staked_lp_shares=s.staked_lp_shares,
        )
        effects = {
            'delta_acc': (new_state.acc_reward_per_share - new_state.last_update_acc),
            'harvested_reward': (0 if 1000000 == 0 else ((((new_state.acc_reward_per_share - cmd.args['entry_acc']) * new_state.staked_lp_shares) // 1000000) + (1 if (((new_state.acc_reward_per_share - cmd.args['entry_acc']) * new_state.staked_lp_shares) % 1000000) < 0 else 0))),
        }
        ok, failed = check_invariants(new_state)
        if not ok:
            return StepResult(ok=False, error=f'post-invariant violated: {failed}')
        return StepResult(ok=True, state=new_state, effects=effects)
    elif cmd.tag == 'stake':
        if 'amount' not in cmd.args or not (isinstance(cmd.args['amount'], int) and not isinstance(cmd.args['amount'], bool) and 1 <= cmd.args['amount'] <= 100):
            return StepResult(ok=False, error='invalid param amount')
        if not ((((((0 if (cmd.args['amount'] + s.staked_lp_shares) == 0 else (((1000000 * s.pending_rewards) // (cmd.args['amount'] + s.staked_lp_shares)) + (1 if ((1000000 * s.pending_rewards) % (cmd.args['amount'] + s.staked_lp_shares)) < 0 else 0))) + s.acc_reward_per_share) <= 1000000000000) if (0 == s.staked_lp_shares) else True) and ((cmd.args['amount'] + s.staked_lp_shares) <= 100))):
            return StepResult(ok=False, error='guard failed for stake')
        # Compute updates (simultaneous)
        new_state = State(
            acc_reward_per_share=(((0 if (cmd.args['amount'] + s.staked_lp_shares) == 0 else (((1000000 * s.pending_rewards) // (cmd.args['amount'] + s.staked_lp_shares)) + (1 if ((1000000 * s.pending_rewards) % (cmd.args['amount'] + s.staked_lp_shares)) < 0 else 0))) if (0 == s.staked_lp_shares) else 0) + s.acc_reward_per_share),
            last_update_acc=s.acc_reward_per_share,
            pending_rewards=((s.pending_rewards - (0 if 1000000 == 0 else ((((cmd.args['amount'] + s.staked_lp_shares) * (0 if (cmd.args['amount'] + s.staked_lp_shares) == 0 else (((1000000 * s.pending_rewards) // (cmd.args['amount'] + s.staked_lp_shares)) + (1 if ((1000000 * s.pending_rewards) % (cmd.args['amount'] + s.staked_lp_shares)) < 0 else 0)))) // 1000000) + (1 if (((cmd.args['amount'] + s.staked_lp_shares) * (0 if (cmd.args['amount'] + s.staked_lp_shares) == 0 else (((1000000 * s.pending_rewards) // (cmd.args['amount'] + s.staked_lp_shares)) + (1 if ((1000000 * s.pending_rewards) % (cmd.args['amount'] + s.staked_lp_shares)) < 0 else 0)))) % 1000000) < 0 else 0)))) if (0 == s.staked_lp_shares) else s.pending_rewards),
            reward_balance=s.reward_balance,
            staked_lp_shares=(cmd.args['amount'] + s.staked_lp_shares),
        )
        effects = {
            'delta_acc': (new_state.acc_reward_per_share - new_state.last_update_acc),
            'harvested_reward': 0,
        }
        ok, failed = check_invariants(new_state)
        if not ok:
            return StepResult(ok=False, error=f'post-invariant violated: {failed}')
        return StepResult(ok=True, state=new_state, effects=effects)
    elif cmd.tag == 'unstake':
        if 'amount' not in cmd.args or not (isinstance(cmd.args['amount'], int) and not isinstance(cmd.args['amount'], bool) and 1 <= cmd.args['amount'] <= 100):
            return StepResult(ok=False, error='invalid param amount')
        if not ((cmd.args['amount'] <= s.staked_lp_shares)):
            return StepResult(ok=False, error='guard failed for unstake')
        # Compute updates (simultaneous)
        new_state = State(
            acc_reward_per_share=s.acc_reward_per_share,
            last_update_acc=s.acc_reward_per_share,
            pending_rewards=s.pending_rewards,
            reward_balance=s.reward_balance,
            staked_lp_shares=(s.staked_lp_shares - cmd.args['amount']),
        )
        effects = {
            'delta_acc': (new_state.acc_reward_per_share - new_state.last_update_acc),
            'harvested_reward': 0,
        }
        ok, failed = check_invariants(new_state)
        if not ok:
            return StepResult(ok=False, error=f'post-invariant violated: {failed}')
        return StepResult(ok=True, state=new_state, effects=effects)
    else:
        return StepResult(ok=False, error=f'unknown action: {cmd.tag}')


# === Hypothesis test scaffolding ===
# Uncomment and install hypothesis to use property-based testing

# from hypothesis import given, strategies as st
# from hypothesis.stateful import RuleBasedStateMachine, rule, initialize
#
# class ModelStateMachine(RuleBasedStateMachine):
#     def __init__(self):
#         super().__init__()
#         self.state = init_state()
#
#     @initialize()
#     def init(self):
#         self.state = init_state()
#         ok, _ = check_invariants(self.state)
#         assert ok, 'init violates invariants'
#
#     # @rule(amount=st.integers())
#     # def deposit_rewards(self, amount):
#     #     cmd = Command(tag='deposit_rewards', args={'amount': amount})
#     #     result = step(self.state, cmd)
#     #     if result.ok:
#     #         self.state = result.state
#
#     # @rule(entry_acc=st.integers())
#     # def harvest(self, entry_acc):
#     #     cmd = Command(tag='harvest', args={'entry_acc': entry_acc})
#     #     result = step(self.state, cmd)
#     #     if result.ok:
#     #         self.state = result.state
#
#     # @rule(amount=st.integers())
#     # def stake(self, amount):
#     #     cmd = Command(tag='stake', args={'amount': amount})
#     #     result = step(self.state, cmd)
#     #     if result.ok:
#     #         self.state = result.state
#
#     # @rule(amount=st.integers())
#     # def unstake(self, amount):
#     #     cmd = Command(tag='unstake', args={'amount': amount})
#     #     result = step(self.state, cmd)
#     #     if result.ok:
#     #         self.state = result.state
#
# TestModel = ModelStateMachine.TestCase


def replay_trace(commands: list[tuple[str, dict[str, Any]]]) -> list[StepResult]:
    """Replay a trace of commands and return results."""
    results: list[StepResult] = []
    s = init_state()
    for tag, args in commands:
        cmd = Command(tag=tag, args=args)
        result = step(s, cmd)
        results.append(result)
        if result.ok and result.state is not None:
            s = result.state
        else:
            break
    return results


if __name__ == '__main__':
    # Quick sanity check
    s0 = init_state()
    ok, failed = check_invariants(s0)
    print(f'Initial state: {s0}')
    print(f'Invariants OK: {ok}')
    if not ok:
        print(f'  Failed: {failed}')
