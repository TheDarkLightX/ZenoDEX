"""
Auto-generated Python reference model for: cpmm_swap
IR hash: sha256:95dd8740ce38b990736bdf59d060104a5626f429181a3414b0a6085101f71d73

Generated by an offline verifier toolchain.

This file is standalone and has no toolchain dependencies.
"""

from __future__ import annotations

from dataclasses import dataclass
from typing import Any, Literal, Mapping


@dataclass(frozen=True)
class State:
    """Model state."""
    fee_bps: int
    reserve_x: int
    reserve_x_before: int
    reserve_y: int
    reserve_y_before: int


@dataclass(frozen=True)
class Command:
    """Command to execute."""
    tag: Literal('swap_x_for_y', 'swap_y_for_x')
    args: Mapping[str, Any]


@dataclass(frozen=True)
class StepResult:
    """Result of a step execution."""
    ok: bool
    state: State | None = None
    effects: Mapping[str, Any] | None = None
    error: str | None = None


def init_state() -> State:
    """Return the initial state."""
    return State(
        fee_bps=30,
        reserve_x=25,
        reserve_x_before=25,
        reserve_y=25,
        reserve_y_before=25,
    )


def check_invariants(s: State) -> tuple[bool, str | None]:
    """Check all invariants. Returns (ok, first_failed_id)."""
    if not (isinstance(s.fee_bps, int) and not isinstance(s.fee_bps, bool) and 0 <= s.fee_bps <= 10000):
        return False, 'domain_fee_bps'
    if not (isinstance(s.reserve_x, int) and not isinstance(s.reserve_x, bool) and 1 <= s.reserve_x <= 50):
        return False, 'domain_reserve_x'
    if not (isinstance(s.reserve_x_before, int) and not isinstance(s.reserve_x_before, bool) and 1 <= s.reserve_x_before <= 50):
        return False, 'domain_reserve_x_before'
    if not (isinstance(s.reserve_y, int) and not isinstance(s.reserve_y, bool) and 1 <= s.reserve_y <= 50):
        return False, 'domain_reserve_y'
    if not (isinstance(s.reserve_y_before, int) and not isinstance(s.reserve_y_before, bool) and 1 <= s.reserve_y_before <= 50):
        return False, 'domain_reserve_y_before'
    if not (((s.reserve_x * s.reserve_y) >= (s.reserve_x_before * s.reserve_y_before))):
        return False, 'inv_k_non_decreasing'
    if not (((s.reserve_x <= 50) and (s.reserve_x > 0))):
        return False, 'inv_reserve_x_bounded'
    if not (((s.reserve_y <= 50) and (s.reserve_y > 0))):
        return False, 'inv_reserve_y_bounded'
    return True, None


def step(s: State, cmd: Command) -> StepResult:
    """Execute a step. Returns StepResult."""
    # History/snapshot vars like `reserve_x_before` are internal-only and exist
    # solely to express transition invariants. Canonicalize them at the boundary
    # so external callers cannot forge them to influence invariant checks.
    s = State(
        fee_bps=s.fee_bps,
        reserve_x=s.reserve_x,
        reserve_x_before=s.reserve_x,
        reserve_y=s.reserve_y,
        reserve_y_before=s.reserve_y,
    )
    # Check pre-state invariants
    ok, failed = check_invariants(s)
    if not ok:
        return StepResult(ok=False, error=f'pre-invariant violated: {failed}')

    if cmd.tag == 'swap_x_for_y':
        if 'amount_in_x' not in cmd.args or not (isinstance(cmd.args['amount_in_x'], int) and not isinstance(cmd.args['amount_in_x'], bool) and 1 <= cmd.args['amount_in_x'] <= 50):
            return StepResult(ok=False, error='invalid param amount_in_x')
        if 'min_amount_out' not in cmd.args or not (isinstance(cmd.args['min_amount_out'], int) and not isinstance(cmd.args['min_amount_out'], bool) and 0 <= cmd.args['min_amount_out'] <= 50):
            return StepResult(ok=False, error='invalid param min_amount_out')
        if not ((((cmd.args['amount_in_x'] + s.reserve_x) <= 50) and ((s.reserve_y - (0 if ((cmd.args['amount_in_x'] - (0 if 10000 == 0 else (((9999 + (cmd.args['amount_in_x'] * s.fee_bps)) // 10000) + (1 if ((9999 + (cmd.args['amount_in_x'] * s.fee_bps)) % 10000) < 0 else 0)))) + s.reserve_x) == 0 else ((((cmd.args['amount_in_x'] - (0 if 10000 == 0 else (((9999 + (cmd.args['amount_in_x'] * s.fee_bps)) // 10000) + (1 if ((9999 + (cmd.args['amount_in_x'] * s.fee_bps)) % 10000) < 0 else 0)))) * s.reserve_y) // ((cmd.args['amount_in_x'] - (0 if 10000 == 0 else (((9999 + (cmd.args['amount_in_x'] * s.fee_bps)) // 10000) + (1 if ((9999 + (cmd.args['amount_in_x'] * s.fee_bps)) % 10000) < 0 else 0)))) + s.reserve_x)) + (1 if (((cmd.args['amount_in_x'] - (0 if 10000 == 0 else (((9999 + (cmd.args['amount_in_x'] * s.fee_bps)) // 10000) + (1 if ((9999 + (cmd.args['amount_in_x'] * s.fee_bps)) % 10000) < 0 else 0)))) * s.reserve_y) % ((cmd.args['amount_in_x'] - (0 if 10000 == 0 else (((9999 + (cmd.args['amount_in_x'] * s.fee_bps)) // 10000) + (1 if ((9999 + (cmd.args['amount_in_x'] * s.fee_bps)) % 10000) < 0 else 0)))) + s.reserve_x)) < 0 else 0)))) >= 1) and ((0 if ((cmd.args['amount_in_x'] - (0 if 10000 == 0 else (((9999 + (cmd.args['amount_in_x'] * s.fee_bps)) // 10000) + (1 if ((9999 + (cmd.args['amount_in_x'] * s.fee_bps)) % 10000) < 0 else 0)))) + s.reserve_x) == 0 else ((((cmd.args['amount_in_x'] - (0 if 10000 == 0 else (((9999 + (cmd.args['amount_in_x'] * s.fee_bps)) // 10000) + (1 if ((9999 + (cmd.args['amount_in_x'] * s.fee_bps)) % 10000) < 0 else 0)))) * s.reserve_y) // ((cmd.args['amount_in_x'] - (0 if 10000 == 0 else (((9999 + (cmd.args['amount_in_x'] * s.fee_bps)) // 10000) + (1 if ((9999 + (cmd.args['amount_in_x'] * s.fee_bps)) % 10000) < 0 else 0)))) + s.reserve_x)) + (1 if (((cmd.args['amount_in_x'] - (0 if 10000 == 0 else (((9999 + (cmd.args['amount_in_x'] * s.fee_bps)) // 10000) + (1 if ((9999 + (cmd.args['amount_in_x'] * s.fee_bps)) % 10000) < 0 else 0)))) * s.reserve_y) % ((cmd.args['amount_in_x'] - (0 if 10000 == 0 else (((9999 + (cmd.args['amount_in_x'] * s.fee_bps)) // 10000) + (1 if ((9999 + (cmd.args['amount_in_x'] * s.fee_bps)) % 10000) < 0 else 0)))) + s.reserve_x)) < 0 else 0))) >= 1) and ((0 if ((cmd.args['amount_in_x'] - (0 if 10000 == 0 else (((9999 + (cmd.args['amount_in_x'] * s.fee_bps)) // 10000) + (1 if ((9999 + (cmd.args['amount_in_x'] * s.fee_bps)) % 10000) < 0 else 0)))) + s.reserve_x) == 0 else ((((cmd.args['amount_in_x'] - (0 if 10000 == 0 else (((9999 + (cmd.args['amount_in_x'] * s.fee_bps)) // 10000) + (1 if ((9999 + (cmd.args['amount_in_x'] * s.fee_bps)) % 10000) < 0 else 0)))) * s.reserve_y) // ((cmd.args['amount_in_x'] - (0 if 10000 == 0 else (((9999 + (cmd.args['amount_in_x'] * s.fee_bps)) // 10000) + (1 if ((9999 + (cmd.args['amount_in_x'] * s.fee_bps)) % 10000) < 0 else 0)))) + s.reserve_x)) + (1 if (((cmd.args['amount_in_x'] - (0 if 10000 == 0 else (((9999 + (cmd.args['amount_in_x'] * s.fee_bps)) // 10000) + (1 if ((9999 + (cmd.args['amount_in_x'] * s.fee_bps)) % 10000) < 0 else 0)))) * s.reserve_y) % ((cmd.args['amount_in_x'] - (0 if 10000 == 0 else (((9999 + (cmd.args['amount_in_x'] * s.fee_bps)) // 10000) + (1 if ((9999 + (cmd.args['amount_in_x'] * s.fee_bps)) % 10000) < 0 else 0)))) + s.reserve_x)) < 0 else 0))) >= cmd.args['min_amount_out']))):
            return StepResult(ok=False, error='guard failed for swap_x_for_y')
        # Compute updates (simultaneous)
        new_state = State(
            fee_bps=s.fee_bps,
            reserve_x=(cmd.args['amount_in_x'] + s.reserve_x),
            reserve_x_before=s.reserve_x,
            reserve_y=(s.reserve_y - (0 if ((cmd.args['amount_in_x'] - (0 if 10000 == 0 else (((9999 + (cmd.args['amount_in_x'] * s.fee_bps)) // 10000) + (1 if ((9999 + (cmd.args['amount_in_x'] * s.fee_bps)) % 10000) < 0 else 0)))) + s.reserve_x) == 0 else ((((cmd.args['amount_in_x'] - (0 if 10000 == 0 else (((9999 + (cmd.args['amount_in_x'] * s.fee_bps)) // 10000) + (1 if ((9999 + (cmd.args['amount_in_x'] * s.fee_bps)) % 10000) < 0 else 0)))) * s.reserve_y) // ((cmd.args['amount_in_x'] - (0 if 10000 == 0 else (((9999 + (cmd.args['amount_in_x'] * s.fee_bps)) // 10000) + (1 if ((9999 + (cmd.args['amount_in_x'] * s.fee_bps)) % 10000) < 0 else 0)))) + s.reserve_x)) + (1 if (((cmd.args['amount_in_x'] - (0 if 10000 == 0 else (((9999 + (cmd.args['amount_in_x'] * s.fee_bps)) // 10000) + (1 if ((9999 + (cmd.args['amount_in_x'] * s.fee_bps)) % 10000) < 0 else 0)))) * s.reserve_y) % ((cmd.args['amount_in_x'] - (0 if 10000 == 0 else (((9999 + (cmd.args['amount_in_x'] * s.fee_bps)) // 10000) + (1 if ((9999 + (cmd.args['amount_in_x'] * s.fee_bps)) % 10000) < 0 else 0)))) + s.reserve_x)) < 0 else 0)))),
            reserve_y_before=s.reserve_y,
        )
        effects = {
            'amount_in': cmd.args['amount_in_x'],
            'amount_out': (new_state.reserve_y_before - new_state.reserve_y),
            'fee_paid': (0 if 10000 == 0 else (((9999 + (cmd.args['amount_in_x'] * new_state.fee_bps)) // 10000) + (1 if ((9999 + (cmd.args['amount_in_x'] * new_state.fee_bps)) % 10000) < 0 else 0))),
            'k_after': (new_state.reserve_x * new_state.reserve_y),
            'k_before': (new_state.reserve_x_before * new_state.reserve_y_before),
            'net_in': (cmd.args['amount_in_x'] - (0 if 10000 == 0 else (((9999 + (cmd.args['amount_in_x'] * new_state.fee_bps)) // 10000) + (1 if ((9999 + (cmd.args['amount_in_x'] * new_state.fee_bps)) % 10000) < 0 else 0)))),
            'swap_dir': 'XForY',
        }
        ok, failed = check_invariants(new_state)
        if not ok:
            return StepResult(ok=False, error=f'post-invariant violated: {failed}')
        return StepResult(ok=True, state=new_state, effects=effects)
    elif cmd.tag == 'swap_y_for_x':
        if 'amount_in_y' not in cmd.args or not (isinstance(cmd.args['amount_in_y'], int) and not isinstance(cmd.args['amount_in_y'], bool) and 1 <= cmd.args['amount_in_y'] <= 50):
            return StepResult(ok=False, error='invalid param amount_in_y')
        if 'min_amount_out' not in cmd.args or not (isinstance(cmd.args['min_amount_out'], int) and not isinstance(cmd.args['min_amount_out'], bool) and 0 <= cmd.args['min_amount_out'] <= 50):
            return StepResult(ok=False, error='invalid param min_amount_out')
        if not ((((cmd.args['amount_in_y'] + s.reserve_y) <= 50) and ((s.reserve_x - (0 if ((cmd.args['amount_in_y'] - (0 if 10000 == 0 else (((9999 + (cmd.args['amount_in_y'] * s.fee_bps)) // 10000) + (1 if ((9999 + (cmd.args['amount_in_y'] * s.fee_bps)) % 10000) < 0 else 0)))) + s.reserve_y) == 0 else ((((cmd.args['amount_in_y'] - (0 if 10000 == 0 else (((9999 + (cmd.args['amount_in_y'] * s.fee_bps)) // 10000) + (1 if ((9999 + (cmd.args['amount_in_y'] * s.fee_bps)) % 10000) < 0 else 0)))) * s.reserve_x) // ((cmd.args['amount_in_y'] - (0 if 10000 == 0 else (((9999 + (cmd.args['amount_in_y'] * s.fee_bps)) // 10000) + (1 if ((9999 + (cmd.args['amount_in_y'] * s.fee_bps)) % 10000) < 0 else 0)))) + s.reserve_y)) + (1 if (((cmd.args['amount_in_y'] - (0 if 10000 == 0 else (((9999 + (cmd.args['amount_in_y'] * s.fee_bps)) // 10000) + (1 if ((9999 + (cmd.args['amount_in_y'] * s.fee_bps)) % 10000) < 0 else 0)))) * s.reserve_x) % ((cmd.args['amount_in_y'] - (0 if 10000 == 0 else (((9999 + (cmd.args['amount_in_y'] * s.fee_bps)) // 10000) + (1 if ((9999 + (cmd.args['amount_in_y'] * s.fee_bps)) % 10000) < 0 else 0)))) + s.reserve_y)) < 0 else 0)))) >= 1) and ((0 if ((cmd.args['amount_in_y'] - (0 if 10000 == 0 else (((9999 + (cmd.args['amount_in_y'] * s.fee_bps)) // 10000) + (1 if ((9999 + (cmd.args['amount_in_y'] * s.fee_bps)) % 10000) < 0 else 0)))) + s.reserve_y) == 0 else ((((cmd.args['amount_in_y'] - (0 if 10000 == 0 else (((9999 + (cmd.args['amount_in_y'] * s.fee_bps)) // 10000) + (1 if ((9999 + (cmd.args['amount_in_y'] * s.fee_bps)) % 10000) < 0 else 0)))) * s.reserve_x) // ((cmd.args['amount_in_y'] - (0 if 10000 == 0 else (((9999 + (cmd.args['amount_in_y'] * s.fee_bps)) // 10000) + (1 if ((9999 + (cmd.args['amount_in_y'] * s.fee_bps)) % 10000) < 0 else 0)))) + s.reserve_y)) + (1 if (((cmd.args['amount_in_y'] - (0 if 10000 == 0 else (((9999 + (cmd.args['amount_in_y'] * s.fee_bps)) // 10000) + (1 if ((9999 + (cmd.args['amount_in_y'] * s.fee_bps)) % 10000) < 0 else 0)))) * s.reserve_x) % ((cmd.args['amount_in_y'] - (0 if 10000 == 0 else (((9999 + (cmd.args['amount_in_y'] * s.fee_bps)) // 10000) + (1 if ((9999 + (cmd.args['amount_in_y'] * s.fee_bps)) % 10000) < 0 else 0)))) + s.reserve_y)) < 0 else 0))) >= 1) and ((0 if ((cmd.args['amount_in_y'] - (0 if 10000 == 0 else (((9999 + (cmd.args['amount_in_y'] * s.fee_bps)) // 10000) + (1 if ((9999 + (cmd.args['amount_in_y'] * s.fee_bps)) % 10000) < 0 else 0)))) + s.reserve_y) == 0 else ((((cmd.args['amount_in_y'] - (0 if 10000 == 0 else (((9999 + (cmd.args['amount_in_y'] * s.fee_bps)) // 10000) + (1 if ((9999 + (cmd.args['amount_in_y'] * s.fee_bps)) % 10000) < 0 else 0)))) * s.reserve_x) // ((cmd.args['amount_in_y'] - (0 if 10000 == 0 else (((9999 + (cmd.args['amount_in_y'] * s.fee_bps)) // 10000) + (1 if ((9999 + (cmd.args['amount_in_y'] * s.fee_bps)) % 10000) < 0 else 0)))) + s.reserve_y)) + (1 if (((cmd.args['amount_in_y'] - (0 if 10000 == 0 else (((9999 + (cmd.args['amount_in_y'] * s.fee_bps)) // 10000) + (1 if ((9999 + (cmd.args['amount_in_y'] * s.fee_bps)) % 10000) < 0 else 0)))) * s.reserve_x) % ((cmd.args['amount_in_y'] - (0 if 10000 == 0 else (((9999 + (cmd.args['amount_in_y'] * s.fee_bps)) // 10000) + (1 if ((9999 + (cmd.args['amount_in_y'] * s.fee_bps)) % 10000) < 0 else 0)))) + s.reserve_y)) < 0 else 0))) >= cmd.args['min_amount_out']))):
            return StepResult(ok=False, error='guard failed for swap_y_for_x')
        # Compute updates (simultaneous)
        new_state = State(
            fee_bps=s.fee_bps,
            reserve_x=(s.reserve_x - (0 if ((cmd.args['amount_in_y'] - (0 if 10000 == 0 else (((9999 + (cmd.args['amount_in_y'] * s.fee_bps)) // 10000) + (1 if ((9999 + (cmd.args['amount_in_y'] * s.fee_bps)) % 10000) < 0 else 0)))) + s.reserve_y) == 0 else ((((cmd.args['amount_in_y'] - (0 if 10000 == 0 else (((9999 + (cmd.args['amount_in_y'] * s.fee_bps)) // 10000) + (1 if ((9999 + (cmd.args['amount_in_y'] * s.fee_bps)) % 10000) < 0 else 0)))) * s.reserve_x) // ((cmd.args['amount_in_y'] - (0 if 10000 == 0 else (((9999 + (cmd.args['amount_in_y'] * s.fee_bps)) // 10000) + (1 if ((9999 + (cmd.args['amount_in_y'] * s.fee_bps)) % 10000) < 0 else 0)))) + s.reserve_y)) + (1 if (((cmd.args['amount_in_y'] - (0 if 10000 == 0 else (((9999 + (cmd.args['amount_in_y'] * s.fee_bps)) // 10000) + (1 if ((9999 + (cmd.args['amount_in_y'] * s.fee_bps)) % 10000) < 0 else 0)))) * s.reserve_x) % ((cmd.args['amount_in_y'] - (0 if 10000 == 0 else (((9999 + (cmd.args['amount_in_y'] * s.fee_bps)) // 10000) + (1 if ((9999 + (cmd.args['amount_in_y'] * s.fee_bps)) % 10000) < 0 else 0)))) + s.reserve_y)) < 0 else 0)))),
            reserve_x_before=s.reserve_x,
            reserve_y=(cmd.args['amount_in_y'] + s.reserve_y),
            reserve_y_before=s.reserve_y,
        )
        effects = {
            'amount_in': cmd.args['amount_in_y'],
            'amount_out': (new_state.reserve_x_before - new_state.reserve_x),
            'fee_paid': (0 if 10000 == 0 else (((9999 + (cmd.args['amount_in_y'] * new_state.fee_bps)) // 10000) + (1 if ((9999 + (cmd.args['amount_in_y'] * new_state.fee_bps)) % 10000) < 0 else 0))),
            'k_after': (new_state.reserve_x * new_state.reserve_y),
            'k_before': (new_state.reserve_x_before * new_state.reserve_y_before),
            'net_in': (cmd.args['amount_in_y'] - (0 if 10000 == 0 else (((9999 + (cmd.args['amount_in_y'] * new_state.fee_bps)) // 10000) + (1 if ((9999 + (cmd.args['amount_in_y'] * new_state.fee_bps)) % 10000) < 0 else 0)))),
            'swap_dir': 'YForX',
        }
        ok, failed = check_invariants(new_state)
        if not ok:
            return StepResult(ok=False, error=f'post-invariant violated: {failed}')
        return StepResult(ok=True, state=new_state, effects=effects)
    else:
        return StepResult(ok=False, error=f'unknown action: {cmd.tag}')


# === Hypothesis test scaffolding ===
# Uncomment and install hypothesis to use property-based testing

# from hypothesis import given, strategies as st
# from hypothesis.stateful import RuleBasedStateMachine, rule, initialize
#
# class ModelStateMachine(RuleBasedStateMachine):
#     def __init__(self):
#         super().__init__()
#         self.state = init_state()
#
#     @initialize()
#     def init(self):
#         self.state = init_state()
#         ok, _ = check_invariants(self.state)
#         assert ok, 'init violates invariants'
#
#     # @rule(amount_in_x=st.integers(), min_amount_out=st.integers())
#     # def swap_x_for_y(self, amount_in_x, min_amount_out):
#     #     cmd = Command(tag='swap_x_for_y', args={'amount_in_x': amount_in_x, 'min_amount_out': min_amount_out})
#     #     result = step(self.state, cmd)
#     #     if result.ok:
#     #         self.state = result.state
#
#     # @rule(amount_in_y=st.integers(), min_amount_out=st.integers())
#     # def swap_y_for_x(self, amount_in_y, min_amount_out):
#     #     cmd = Command(tag='swap_y_for_x', args={'amount_in_y': amount_in_y, 'min_amount_out': min_amount_out})
#     #     result = step(self.state, cmd)
#     #     if result.ok:
#     #         self.state = result.state
#
# TestModel = ModelStateMachine.TestCase


def replay_trace(commands: list[tuple[str, dict[str, Any]]]) -> list[StepResult]:
    """Replay a trace of commands and return results."""
    results: list[StepResult] = []
    s = init_state()
    for tag, args in commands:
        cmd = Command(tag=tag, args=args)
        result = step(s, cmd)
        results.append(result)
        if result.ok and result.state is not None:
            s = result.state
        else:
            break
    return results


if __name__ == '__main__':
    # Quick sanity check
    s0 = init_state()
    ok, failed = check_invariants(s0)
    print(f'Initial state: {s0}')
    print(f'Invariants OK: {ok}')
    if not ok:
        print(f'  Failed: {failed}')
