"""
Auto-generated Python reference model for: lp_mint_v7
IR hash: sha256:b7d6d0a1f53af56a21ff176583f80d729da1bea5d8267b66458316f3bdfe8dc5

Generated by an offline verifier toolchain.

This file is standalone and has no toolchain dependencies.
"""

from __future__ import annotations

from dataclasses import dataclass
from typing import Any, Literal, Mapping


@dataclass(frozen=True)
class State:
    """Model state."""
    locked_liquidity: int
    lp_supply: int
    lp_supply_before: int
    reserve0: int
    reserve0_before: int
    reserve1: int
    reserve1_before: int


@dataclass(frozen=True)
class Command:
    """Command to execute."""
    tag: Literal('mint', 'mint_initial')
    args: Mapping[str, Any]


@dataclass(frozen=True)
class StepResult:
    """Result of a step execution."""
    ok: bool
    state: State | None = None
    effects: Mapping[str, Any] | None = None
    error: str | None = None


def init_state() -> State:
    """Return the initial state."""
    return State(
        locked_liquidity=0,
        lp_supply=0,
        lp_supply_before=0,
        reserve0=0,
        reserve0_before=0,
        reserve1=0,
        reserve1_before=0,
    )


def check_invariants(s: State) -> tuple[bool, str | None]:
    """Check all invariants. Returns (ok, first_failed_id)."""
    if not (isinstance(s.locked_liquidity, int) and not isinstance(s.locked_liquidity, bool) and 0 <= s.locked_liquidity <= 1000):
        return False, 'domain_locked_liquidity'
    if not (isinstance(s.lp_supply, int) and not isinstance(s.lp_supply, bool) and 0 <= s.lp_supply <= 3000000000):
        return False, 'domain_lp_supply'
    if not (isinstance(s.lp_supply_before, int) and not isinstance(s.lp_supply_before, bool) and 0 <= s.lp_supply_before <= 3000000000):
        return False, 'domain_lp_supply_before'
    if not (isinstance(s.reserve0, int) and not isinstance(s.reserve0, bool) and 0 <= s.reserve0 <= 3000000000):
        return False, 'domain_reserve0'
    if not (isinstance(s.reserve0_before, int) and not isinstance(s.reserve0_before, bool) and 0 <= s.reserve0_before <= 3000000000):
        return False, 'domain_reserve0_before'
    if not (isinstance(s.reserve1, int) and not isinstance(s.reserve1, bool) and 0 <= s.reserve1 <= 3000000000):
        return False, 'domain_reserve1'
    if not (isinstance(s.reserve1_before, int) and not isinstance(s.reserve1_before, bool) and 0 <= s.reserve1_before <= 3000000000):
        return False, 'domain_reserve1_before'
    if not (((s.lp_supply <= 3000000000) and (s.reserve0 <= 3000000000) and (s.reserve1 <= 3000000000))):
        return False, 'inv_bounds'
    if not (((0 == s.locked_liquidity) or (1000 == s.locked_liquidity))):
        return False, 'inv_locked_valid'
    if not ((((0 == s.locked_liquidity) and (0 == s.lp_supply) and (0 == s.reserve0) and (0 == s.reserve1)) or ((1000 == s.locked_liquidity) and (s.reserve0 > 0) and (s.reserve1 > 0) and (s.lp_supply >= 0)))):
        return False, 'inv_pool_consistency'
    if not (((s.lp_supply >= 0) and (s.reserve0 >= 0) and (s.reserve1 >= 0))):
        return False, 'inv_reserves_nonneg'
    return True, None


def step(s: State, cmd: Command) -> StepResult:
    """Execute a step. Returns StepResult."""
    # Check pre-state invariants
    ok, failed = check_invariants(s)
    if not ok:
        return StepResult(ok=False, error=f'pre-invariant violated: {failed}')

    if cmd.tag == 'mint':
        if 'amount0' not in cmd.args or not (isinstance(cmd.args['amount0'], int) and not isinstance(cmd.args['amount0'], bool) and 1 <= cmd.args['amount0'] <= 1000000000):
            return StepResult(ok=False, error='invalid param amount0')
        if 'amount1' not in cmd.args or not (isinstance(cmd.args['amount1'], int) and not isinstance(cmd.args['amount1'], bool) and 1 <= cmd.args['amount1'] <= 1000000000):
            return StepResult(ok=False, error='invalid param amount1')
        if 'min_liquidity' not in cmd.args or not (isinstance(cmd.args['min_liquidity'], int) and not isinstance(cmd.args['min_liquidity'], bool) and 0 <= cmd.args['min_liquidity'] <= 3000000000):
            return StepResult(ok=False, error='invalid param min_liquidity')
        if not (((((0 if s.reserve0 == 0 else (((cmd.args['amount0'] * s.reserve1) // s.reserve0) + (1 if ((cmd.args['amount0'] * s.reserve1) % s.reserve0) < 0 else 0))) if ((cmd.args['amount0'] * s.reserve1) <= (cmd.args['amount1'] * s.reserve0)) else cmd.args['amount1']) <= cmd.args['amount1']) and ((cmd.args['amount0'] if ((cmd.args['amount0'] * s.reserve1) <= (cmd.args['amount1'] * s.reserve0)) else (0 if s.reserve1 == 0 else (((cmd.args['amount1'] * s.reserve0) // s.reserve1) + (1 if ((cmd.args['amount1'] * s.reserve0) % s.reserve1) < 0 else 0)))) <= cmd.args['amount0']) and ((((0 if s.reserve0 == 0 else ((((s.locked_liquidity + s.lp_supply) * cmd.args['amount0']) // s.reserve0) + (1 if (((s.locked_liquidity + s.lp_supply) * cmd.args['amount0']) % s.reserve0) < 0 else 0))) if ((cmd.args['amount0'] * s.reserve1) <= (cmd.args['amount1'] * s.reserve0)) else (0 if s.reserve1 == 0 else ((((s.locked_liquidity + s.lp_supply) * cmd.args['amount1']) // s.reserve1) + (1 if (((s.locked_liquidity + s.lp_supply) * cmd.args['amount1']) % s.reserve1) < 0 else 0)))) + s.lp_supply) <= 3000000000) and ((cmd.args['amount0'] + s.reserve0) <= 3000000000) and ((cmd.args['amount1'] + s.reserve1) <= 3000000000) and (1000 == s.locked_liquidity) and (((0 if s.reserve0 == 0 else ((((s.locked_liquidity + s.lp_supply) * cmd.args['amount0']) // s.reserve0) + (1 if (((s.locked_liquidity + s.lp_supply) * cmd.args['amount0']) % s.reserve0) < 0 else 0))) if ((cmd.args['amount0'] * s.reserve1) <= (cmd.args['amount1'] * s.reserve0)) else (0 if s.reserve1 == 0 else ((((s.locked_liquidity + s.lp_supply) * cmd.args['amount1']) // s.reserve1) + (1 if (((s.locked_liquidity + s.lp_supply) * cmd.args['amount1']) % s.reserve1) < 0 else 0)))) > 0) and (cmd.args['amount0'] > 0) and (cmd.args['amount1'] > 0) and (s.reserve0 > 0) and (s.reserve1 > 0) and (((0 if s.reserve0 == 0 else ((((s.locked_liquidity + s.lp_supply) * cmd.args['amount0']) // s.reserve0) + (1 if (((s.locked_liquidity + s.lp_supply) * cmd.args['amount0']) % s.reserve0) < 0 else 0))) if ((cmd.args['amount0'] * s.reserve1) <= (cmd.args['amount1'] * s.reserve0)) else (0 if s.reserve1 == 0 else ((((s.locked_liquidity + s.lp_supply) * cmd.args['amount1']) // s.reserve1) + (1 if (((s.locked_liquidity + s.lp_supply) * cmd.args['amount1']) % s.reserve1) < 0 else 0)))) >= cmd.args['min_liquidity']))):
            return StepResult(ok=False, error='guard failed for mint')
        # Compute updates (simultaneous)
        new_state = State(
            locked_liquidity=s.locked_liquidity,
            lp_supply=(((0 if s.reserve0 == 0 else ((((s.locked_liquidity + s.lp_supply) * cmd.args['amount0']) // s.reserve0) + (1 if (((s.locked_liquidity + s.lp_supply) * cmd.args['amount0']) % s.reserve0) < 0 else 0))) if ((cmd.args['amount0'] * s.reserve1) <= (cmd.args['amount1'] * s.reserve0)) else (0 if s.reserve1 == 0 else ((((s.locked_liquidity + s.lp_supply) * cmd.args['amount1']) // s.reserve1) + (1 if (((s.locked_liquidity + s.lp_supply) * cmd.args['amount1']) % s.reserve1) < 0 else 0)))) + s.lp_supply),
            lp_supply_before=s.lp_supply,
            reserve0=((cmd.args['amount0'] if ((cmd.args['amount0'] * s.reserve1) <= (cmd.args['amount1'] * s.reserve0)) else (0 if s.reserve1 == 0 else (((cmd.args['amount1'] * s.reserve0) // s.reserve1) + (1 if ((cmd.args['amount1'] * s.reserve0) % s.reserve1) < 0 else 0)))) + s.reserve0),
            reserve0_before=s.reserve0,
            reserve1=(((0 if s.reserve0 == 0 else (((cmd.args['amount0'] * s.reserve1) // s.reserve0) + (1 if ((cmd.args['amount0'] * s.reserve1) % s.reserve0) < 0 else 0))) if ((cmd.args['amount0'] * s.reserve1) <= (cmd.args['amount1'] * s.reserve0)) else cmd.args['amount1']) + s.reserve1),
            reserve1_before=s.reserve1,
        )
        effects = {
            'amount0_refund': (cmd.args['amount0'] - (new_state.reserve0 - new_state.reserve0_before)),
            'amount0_used': (new_state.reserve0 - new_state.reserve0_before),
            'amount1_refund': (cmd.args['amount1'] - (new_state.reserve1 - new_state.reserve1_before)),
            'amount1_used': (new_state.reserve1 - new_state.reserve1_before),
            'liquidity_minted': (new_state.lp_supply - new_state.lp_supply_before),
            'total_supply': (new_state.locked_liquidity + new_state.lp_supply),
        }
        ok, failed = check_invariants(new_state)
        if not ok:
            return StepResult(ok=False, error=f'post-invariant violated: {failed}')
        return StepResult(ok=True, state=new_state, effects=effects)
    elif cmd.tag == 'mint_initial':
        if 'amount0' not in cmd.args or not (isinstance(cmd.args['amount0'], int) and not isinstance(cmd.args['amount0'], bool) and 1001 <= cmd.args['amount0'] <= 1000000000):
            return StepResult(ok=False, error='invalid param amount0')
        if 'amount1' not in cmd.args or not (isinstance(cmd.args['amount1'], int) and not isinstance(cmd.args['amount1'], bool) and 1001 <= cmd.args['amount1'] <= 1000000000):
            return StepResult(ok=False, error='invalid param amount1')
        if 'sqrt_product' not in cmd.args or not (isinstance(cmd.args['sqrt_product'], int) and not isinstance(cmd.args['sqrt_product'], bool) and 1001 <= cmd.args['sqrt_product'] <= 1000000000):
            return StepResult(ok=False, error='invalid param sqrt_product')
        if not ((((cmd.args['amount0'] * cmd.args['amount1']) < ((1 + cmd.args['sqrt_product']) * (1 + cmd.args['sqrt_product']))) and ((cmd.args['sqrt_product'] * cmd.args['sqrt_product']) <= (cmd.args['amount0'] * cmd.args['amount1'])) and ((cmd.args['sqrt_product'] - 1000) <= 3000000000) and (cmd.args['amount0'] <= 3000000000) and (cmd.args['amount1'] <= 3000000000) and (0 == s.locked_liquidity) and (0 == s.lp_supply) and (0 == s.reserve0) and (0 == s.reserve1) and (cmd.args['amount0'] > 1000) and (cmd.args['amount1'] > 1000) and (cmd.args['sqrt_product'] > 1000))):
            return StepResult(ok=False, error='guard failed for mint_initial')
        # Compute updates (simultaneous)
        new_state = State(
            locked_liquidity=1000,
            lp_supply=(cmd.args['sqrt_product'] - 1000),
            lp_supply_before=s.lp_supply,
            reserve0=cmd.args['amount0'],
            reserve0_before=s.reserve0,
            reserve1=cmd.args['amount1'],
            reserve1_before=s.reserve1,
        )
        effects = {
            'amount0_refund': (cmd.args['amount0'] - (new_state.reserve0 - new_state.reserve0_before)),
            'amount0_used': (new_state.reserve0 - new_state.reserve0_before),
            'amount1_refund': (cmd.args['amount1'] - (new_state.reserve1 - new_state.reserve1_before)),
            'amount1_used': (new_state.reserve1 - new_state.reserve1_before),
            'liquidity_minted': (new_state.lp_supply - new_state.lp_supply_before),
            'total_supply': (new_state.locked_liquidity + new_state.lp_supply),
        }
        ok, failed = check_invariants(new_state)
        if not ok:
            return StepResult(ok=False, error=f'post-invariant violated: {failed}')
        return StepResult(ok=True, state=new_state, effects=effects)
    else:
        return StepResult(ok=False, error=f'unknown action: {cmd.tag}')


# === Hypothesis test scaffolding ===
# Uncomment and install hypothesis to use property-based testing

# from hypothesis import given, strategies as st
# from hypothesis.stateful import RuleBasedStateMachine, rule, initialize
#
# class ModelStateMachine(RuleBasedStateMachine):
#     def __init__(self):
#         super().__init__()
#         self.state = init_state()
#
#     @initialize()
#     def init(self):
#         self.state = init_state()
#         ok, _ = check_invariants(self.state)
#         assert ok, 'init violates invariants'
#
#     # @rule(amount0=st.integers(), amount1=st.integers(), min_liquidity=st.integers())
#     # def mint(self, amount0, amount1, min_liquidity):
#     #     cmd = Command(tag='mint', args={'amount0': amount0, 'amount1': amount1, 'min_liquidity': min_liquidity})
#     #     result = step(self.state, cmd)
#     #     if result.ok:
#     #         self.state = result.state
#
#     # @rule(amount0=st.integers(), amount1=st.integers(), sqrt_product=st.integers())
#     # def mint_initial(self, amount0, amount1, sqrt_product):
#     #     cmd = Command(tag='mint_initial', args={'amount0': amount0, 'amount1': amount1, 'sqrt_product': sqrt_product})
#     #     result = step(self.state, cmd)
#     #     if result.ok:
#     #         self.state = result.state
#
# TestModel = ModelStateMachine.TestCase


def replay_trace(commands: list[tuple[str, dict[str, Any]]]) -> list[StepResult]:
    """Replay a trace of commands and return results."""
    results: list[StepResult] = []
    s = init_state()
    for tag, args in commands:
        cmd = Command(tag=tag, args=args)
        result = step(s, cmd)
        results.append(result)
        if result.ok and result.state is not None:
            s = result.state
        else:
            break
    return results


if __name__ == '__main__':
    # Quick sanity check
    s0 = init_state()
    ok, failed = check_invariants(s0)
    print(f'Initial state: {s0}')
    print(f'Invariants OK: {ok}')
    if not ok:
        print(f'  Failed: {failed}')
