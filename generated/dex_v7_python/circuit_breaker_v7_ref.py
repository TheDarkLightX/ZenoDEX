"""
Auto-generated Python reference model for: circuit_breaker_v7
IR hash: sha256:5f6b310bd59573629a0502835c8efd26353c11df34ef95907ca8038482ea2a73

Generated by an offline verifier toolchain.

This file is standalone and has no toolchain dependencies.
"""

from __future__ import annotations

from dataclasses import dataclass
from typing import Any, Literal, Mapping


@dataclass(frozen=True)
class State:
    """Model state."""
    breaker_open: bool
    cooldown_duration: int
    max_volume: int
    trigger_time: int
    volume_accumulated: int
    window_duration: int
    window_start: int


@dataclass(frozen=True)
class Command:
    """Command to execute."""
    tag: Literal('add_volume', 'configure', 'reset')
    args: Mapping[str, Any]


@dataclass(frozen=True)
class StepResult:
    """Result of a step execution."""
    ok: bool
    state: State | None = None
    effects: Mapping[str, Any] | None = None
    error: str | None = None


def init_state() -> State:
    """Return the initial state."""
    return State(
        breaker_open=False,
        cooldown_duration=300,
        max_volume=100000000,
        trigger_time=0,
        volume_accumulated=0,
        window_duration=3600,
        window_start=0,
    )


def check_invariants(s: State) -> tuple[bool, str | None]:
    """Check all invariants. Returns (ok, first_failed_id)."""
    if not (isinstance(s.breaker_open, bool)):
        return False, 'domain_breaker_open'
    if not (isinstance(s.cooldown_duration, int) and not isinstance(s.cooldown_duration, bool) and 1 <= s.cooldown_duration <= 86400):
        return False, 'domain_cooldown_duration'
    if not (isinstance(s.max_volume, int) and not isinstance(s.max_volume, bool) and 1 <= s.max_volume <= 1000000000):
        return False, 'domain_max_volume'
    if not (isinstance(s.trigger_time, int) and not isinstance(s.trigger_time, bool) and 0 <= s.trigger_time <= 2000000000):
        return False, 'domain_trigger_time'
    if not (isinstance(s.volume_accumulated, int) and not isinstance(s.volume_accumulated, bool) and 0 <= s.volume_accumulated <= 1000000000):
        return False, 'domain_volume_accumulated'
    if not (isinstance(s.window_duration, int) and not isinstance(s.window_duration, bool) and 1 <= s.window_duration <= 86400):
        return False, 'domain_window_duration'
    if not (isinstance(s.window_start, int) and not isinstance(s.window_start, bool) and 0 <= s.window_start <= 2000000000):
        return False, 'domain_window_start'
    if not (((0 == s.trigger_time) or s.breaker_open)):
        return False, 'inv_closed_no_trigger'
    if not (((s.cooldown_duration > 0) and (s.max_volume > 0) and (s.window_duration > 0))):
        return False, 'inv_config_valid'
    if not (((s.trigger_time > 0) or (not s.breaker_open))):
        return False, 'inv_open_has_trigger'
    if not (((s.volume_accumulated <= s.max_volume) and (s.volume_accumulated >= 0))):
        return False, 'inv_volume_bounded'
    return True, None


def step(s: State, cmd: Command) -> StepResult:
    """Execute a step. Returns StepResult."""
    # Check pre-state invariants
    ok, failed = check_invariants(s)
    if not ok:
        return StepResult(ok=False, error=f'pre-invariant violated: {failed}')

    if cmd.tag == 'add_volume':
        if 'volume' not in cmd.args or not (isinstance(cmd.args['volume'], int) and not isinstance(cmd.args['volume'], bool) and 1 <= cmd.args['volume'] <= 100000000):
            return StepResult(ok=False, error='invalid param volume')
        if 'current_time' not in cmd.args or not (isinstance(cmd.args['current_time'], int) and not isinstance(cmd.args['current_time'], bool) and 1 <= cmd.args['current_time'] <= 2000000000):
            return StepResult(ok=False, error='invalid param current_time')
        if not (((cmd.args['volume'] > 0) and (cmd.args['current_time'] >= s.window_start) and (not s.breaker_open))):
            return StepResult(ok=False, error='guard failed for add_volume')
        # Compute updates (simultaneous)
        new_state = State(
            breaker_open=(((cmd.args['volume'] if (cmd.args['volume'] <= s.max_volume) else s.max_volume) if ((cmd.args['current_time'] - s.window_start) >= s.window_duration) else ((cmd.args['volume'] + s.volume_accumulated) if ((cmd.args['volume'] + s.volume_accumulated) <= s.max_volume) else s.max_volume)) >= s.max_volume),
            cooldown_duration=s.cooldown_duration,
            max_volume=s.max_volume,
            trigger_time=(cmd.args['current_time'] if (((cmd.args['volume'] if (cmd.args['volume'] <= s.max_volume) else s.max_volume) if ((cmd.args['current_time'] - s.window_start) >= s.window_duration) else ((cmd.args['volume'] + s.volume_accumulated) if ((cmd.args['volume'] + s.volume_accumulated) <= s.max_volume) else s.max_volume)) >= s.max_volume) else 0),
            volume_accumulated=((cmd.args['volume'] if (cmd.args['volume'] <= s.max_volume) else s.max_volume) if ((cmd.args['current_time'] - s.window_start) >= s.window_duration) else ((cmd.args['volume'] + s.volume_accumulated) if ((cmd.args['volume'] + s.volume_accumulated) <= s.max_volume) else s.max_volume)),
            window_duration=s.window_duration,
            window_start=(cmd.args['current_time'] if ((cmd.args['current_time'] - s.window_start) >= s.window_duration) else s.window_start),
        )
        effects = {
            'can_trade': (not new_state.breaker_open),
            'triggered': new_state.breaker_open,
            'volume_after': new_state.volume_accumulated,
        }
        ok, failed = check_invariants(new_state)
        if not ok:
            return StepResult(ok=False, error=f'post-invariant violated: {failed}')
        return StepResult(ok=True, state=new_state, effects=effects)
    elif cmd.tag == 'configure':
        if 'caller_is_admin' not in cmd.args or not (isinstance(cmd.args['caller_is_admin'], bool)):
            return StepResult(ok=False, error='invalid param caller_is_admin')
        if 'new_max_volume' not in cmd.args or not (isinstance(cmd.args['new_max_volume'], int) and not isinstance(cmd.args['new_max_volume'], bool) and 1 <= cmd.args['new_max_volume'] <= 1000000000):
            return StepResult(ok=False, error='invalid param new_max_volume')
        if 'new_window_duration' not in cmd.args or not (isinstance(cmd.args['new_window_duration'], int) and not isinstance(cmd.args['new_window_duration'], bool) and 1 <= cmd.args['new_window_duration'] <= 86400):
            return StepResult(ok=False, error='invalid param new_window_duration')
        if 'new_cooldown_duration' not in cmd.args or not (isinstance(cmd.args['new_cooldown_duration'], int) and not isinstance(cmd.args['new_cooldown_duration'], bool) and 1 <= cmd.args['new_cooldown_duration'] <= 86400):
            return StepResult(ok=False, error='invalid param new_cooldown_duration')
        if 'current_time' not in cmd.args or not (isinstance(cmd.args['current_time'], int) and not isinstance(cmd.args['current_time'], bool) and 0 <= cmd.args['current_time'] <= 2000000000):
            return StepResult(ok=False, error='invalid param current_time')
        if not (((cmd.args['new_cooldown_duration'] > 0) and (cmd.args['new_max_volume'] > 0) and (cmd.args['new_window_duration'] > 0) and (not s.breaker_open) and cmd.args['caller_is_admin'])):
            return StepResult(ok=False, error='guard failed for configure')
        # Compute updates (simultaneous)
        new_state = State(
            breaker_open=False,
            cooldown_duration=cmd.args['new_cooldown_duration'],
            max_volume=cmd.args['new_max_volume'],
            trigger_time=0,
            volume_accumulated=0,
            window_duration=cmd.args['new_window_duration'],
            window_start=cmd.args['current_time'],
        )
        effects = {
            'can_trade': True,
            'triggered': False,
            'volume_after': 0,
        }
        ok, failed = check_invariants(new_state)
        if not ok:
            return StepResult(ok=False, error=f'post-invariant violated: {failed}')
        return StepResult(ok=True, state=new_state, effects=effects)
    elif cmd.tag == 'reset':
        if 'caller_is_admin' not in cmd.args or not (isinstance(cmd.args['caller_is_admin'], bool)):
            return StepResult(ok=False, error='invalid param caller_is_admin')
        if 'current_time' not in cmd.args or not (isinstance(cmd.args['current_time'], int) and not isinstance(cmd.args['current_time'], bool) and 1 <= cmd.args['current_time'] <= 2000000000):
            return StepResult(ok=False, error='invalid param current_time')
        if not ((((cmd.args['current_time'] - s.trigger_time) >= s.cooldown_duration) and (cmd.args['current_time'] >= s.trigger_time) and cmd.args['caller_is_admin'] and s.breaker_open)):
            return StepResult(ok=False, error='guard failed for reset')
        # Compute updates (simultaneous)
        new_state = State(
            breaker_open=False,
            cooldown_duration=s.cooldown_duration,
            max_volume=s.max_volume,
            trigger_time=0,
            volume_accumulated=0,
            window_duration=s.window_duration,
            window_start=cmd.args['current_time'],
        )
        effects = {
            'can_trade': True,
            'triggered': False,
            'volume_after': 0,
        }
        ok, failed = check_invariants(new_state)
        if not ok:
            return StepResult(ok=False, error=f'post-invariant violated: {failed}')
        return StepResult(ok=True, state=new_state, effects=effects)
    else:
        return StepResult(ok=False, error=f'unknown action: {cmd.tag}')


# === Hypothesis test scaffolding ===
# Uncomment and install hypothesis to use property-based testing

# from hypothesis import given, strategies as st
# from hypothesis.stateful import RuleBasedStateMachine, rule, initialize
#
# class ModelStateMachine(RuleBasedStateMachine):
#     def __init__(self):
#         super().__init__()
#         self.state = init_state()
#
#     @initialize()
#     def init(self):
#         self.state = init_state()
#         ok, _ = check_invariants(self.state)
#         assert ok, 'init violates invariants'
#
#     # @rule(volume=st.integers(), current_time=st.integers())
#     # def add_volume(self, volume, current_time):
#     #     cmd = Command(tag='add_volume', args={'volume': volume, 'current_time': current_time})
#     #     result = step(self.state, cmd)
#     #     if result.ok:
#     #         self.state = result.state
#
#     # @rule(caller_is_admin=st.integers(), new_max_volume=st.integers(), new_window_duration=st.integers(), new_cooldown_duration=st.integers(), current_time=st.integers())
#     # def configure(self, caller_is_admin, new_max_volume, new_window_duration, new_cooldown_duration, current_time):
#     #     cmd = Command(tag='configure', args={'caller_is_admin': caller_is_admin, 'new_max_volume': new_max_volume, 'new_window_duration': new_window_duration, 'new_cooldown_duration': new_cooldown_duration, 'current_time': current_time})
#     #     result = step(self.state, cmd)
#     #     if result.ok:
#     #         self.state = result.state
#
#     # @rule(caller_is_admin=st.integers(), current_time=st.integers())
#     # def reset(self, caller_is_admin, current_time):
#     #     cmd = Command(tag='reset', args={'caller_is_admin': caller_is_admin, 'current_time': current_time})
#     #     result = step(self.state, cmd)
#     #     if result.ok:
#     #         self.state = result.state
#
# TestModel = ModelStateMachine.TestCase


def replay_trace(commands: list[tuple[str, dict[str, Any]]]) -> list[StepResult]:
    """Replay a trace of commands and return results."""
    results: list[StepResult] = []
    s = init_state()
    for tag, args in commands:
        cmd = Command(tag=tag, args=args)
        result = step(s, cmd)
        results.append(result)
        if result.ok and result.state is not None:
            s = result.state
        else:
            break
    return results


if __name__ == '__main__':
    # Quick sanity check
    s0 = init_state()
    ok, failed = check_invariants(s0)
    print(f'Initial state: {s0}')
    print(f'Invariants OK: {ok}')
    if not ok:
        print(f'  Failed: {failed}')
