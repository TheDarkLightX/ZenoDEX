"""
Auto-generated Python reference model for: liquidity_pool
IR hash: sha256:3db4b93a7dec89a2d5b84b76997eec165d03f2b6c74033185a1f15a12471cc46

Generated by an offline verifier toolchain.

This file is standalone and has no toolchain dependencies.
"""

from __future__ import annotations

from dataclasses import dataclass
from typing import Any, Literal, Mapping


@dataclass(frozen=True)
class State:
    """Model state."""
    reserve_a: int
    reserve_a_before: int
    reserve_b: int
    reserve_b_before: int
    total_lp_shares: int
    total_lp_shares_before: int


@dataclass(frozen=True)
class Command:
    """Command to execute."""
    tag: Literal('add_liquidity', 'remove_liquidity')
    args: Mapping[str, Any]


@dataclass(frozen=True)
class StepResult:
    """Result of a step execution."""
    ok: bool
    state: State | None = None
    effects: Mapping[str, Any] | None = None
    error: str | None = None


def init_state() -> State:
    """Return the initial state."""
    return State(
        reserve_a=25,
        reserve_a_before=25,
        reserve_b=25,
        reserve_b_before=25,
        total_lp_shares=50,
        total_lp_shares_before=50,
    )


def check_invariants(s: State) -> tuple[bool, str | None]:
    """Check all invariants. Returns (ok, first_failed_id)."""
    if not (isinstance(s.reserve_a, int) and not isinstance(s.reserve_a, bool) and 1 <= s.reserve_a <= 45):
        return False, 'domain_reserve_a'
    if not (isinstance(s.reserve_a_before, int) and not isinstance(s.reserve_a_before, bool) and 1 <= s.reserve_a_before <= 45):
        return False, 'domain_reserve_a_before'
    if not (isinstance(s.reserve_b, int) and not isinstance(s.reserve_b, bool) and 1 <= s.reserve_b <= 45):
        return False, 'domain_reserve_b'
    if not (isinstance(s.reserve_b_before, int) and not isinstance(s.reserve_b_before, bool) and 1 <= s.reserve_b_before <= 45):
        return False, 'domain_reserve_b_before'
    if not (isinstance(s.total_lp_shares, int) and not isinstance(s.total_lp_shares, bool) and 1 <= s.total_lp_shares <= 60):
        return False, 'domain_total_lp_shares'
    if not (isinstance(s.total_lp_shares_before, int) and not isinstance(s.total_lp_shares_before, bool) and 1 <= s.total_lp_shares_before <= 60):
        return False, 'domain_total_lp_shares_before'
    if not (((not ((s.reserve_a > 0) and (s.reserve_b > 0))) or (s.total_lp_shares > 0))):
        return False, 'inv_lp_supply_positive_when_reserves_positive'
    if not (((s.reserve_a <= 45) and (s.reserve_a > 0))):
        return False, 'inv_reserve_a_bounded'
    if not (((s.reserve_b <= 45) and (s.reserve_b > 0))):
        return False, 'inv_reserve_b_bounded'
    return True, None


def step(s: State, cmd: Command) -> StepResult:
    """Execute a step. Returns StepResult."""
    # History/snapshot vars like `reserve_a_before` are internal-only and exist
    # solely to express transition effects safely. Canonicalize them at the
    # boundary so external callers cannot forge them to influence validation.
    s = State(
        reserve_a=s.reserve_a,
        reserve_a_before=s.reserve_a,
        reserve_b=s.reserve_b,
        reserve_b_before=s.reserve_b,
        total_lp_shares=s.total_lp_shares,
        total_lp_shares_before=s.total_lp_shares,
    )
    # Check pre-state invariants
    ok, failed = check_invariants(s)
    if not ok:
        return StepResult(ok=False, error=f'pre-invariant violated: {failed}')

    if cmd.tag == 'add_liquidity':
        if 'amount_a_in' not in cmd.args or not (isinstance(cmd.args['amount_a_in'], int) and not isinstance(cmd.args['amount_a_in'], bool) and 1 <= cmd.args['amount_a_in'] <= 50):
            return StepResult(ok=False, error='invalid param amount_a_in')
        if 'amount_b_in' not in cmd.args or not (isinstance(cmd.args['amount_b_in'], int) and not isinstance(cmd.args['amount_b_in'], bool) and 1 <= cmd.args['amount_b_in'] <= 50):
            return StepResult(ok=False, error='invalid param amount_b_in')
        if not ((((((0 if s.reserve_a == 0 else (((cmd.args['amount_a_in'] * s.total_lp_shares) // s.reserve_a) + (1 if ((cmd.args['amount_a_in'] * s.total_lp_shares) % s.reserve_a) < 0 else 0))) if ((0 if s.reserve_a == 0 else (((cmd.args['amount_a_in'] * s.total_lp_shares) // s.reserve_a) + (1 if ((cmd.args['amount_a_in'] * s.total_lp_shares) % s.reserve_a) < 0 else 0))) <= (0 if s.reserve_b == 0 else (((cmd.args['amount_b_in'] * s.total_lp_shares) // s.reserve_b) + (1 if ((cmd.args['amount_b_in'] * s.total_lp_shares) % s.reserve_b) < 0 else 0)))) else (0 if s.reserve_b == 0 else (((cmd.args['amount_b_in'] * s.total_lp_shares) // s.reserve_b) + (1 if ((cmd.args['amount_b_in'] * s.total_lp_shares) % s.reserve_b) < 0 else 0)))) + s.total_lp_shares) <= 60) and ((cmd.args['amount_a_in'] + s.reserve_a) <= 45) and ((cmd.args['amount_b_in'] + s.reserve_b) <= 45) and (((0 if s.reserve_a == 0 else (((cmd.args['amount_a_in'] * s.total_lp_shares) // s.reserve_a) + (1 if ((cmd.args['amount_a_in'] * s.total_lp_shares) % s.reserve_a) < 0 else 0))) if ((0 if s.reserve_a == 0 else (((cmd.args['amount_a_in'] * s.total_lp_shares) // s.reserve_a) + (1 if ((cmd.args['amount_a_in'] * s.total_lp_shares) % s.reserve_a) < 0 else 0))) <= (0 if s.reserve_b == 0 else (((cmd.args['amount_b_in'] * s.total_lp_shares) // s.reserve_b) + (1 if ((cmd.args['amount_b_in'] * s.total_lp_shares) % s.reserve_b) < 0 else 0)))) else (0 if s.reserve_b == 0 else (((cmd.args['amount_b_in'] * s.total_lp_shares) // s.reserve_b) + (1 if ((cmd.args['amount_b_in'] * s.total_lp_shares) % s.reserve_b) < 0 else 0)))) >= 1))):
            return StepResult(ok=False, error='guard failed for add_liquidity')
        # Compute updates (simultaneous)
        new_state = State(
            reserve_a=(cmd.args['amount_a_in'] + s.reserve_a),
            reserve_a_before=s.reserve_a,
            reserve_b=(cmd.args['amount_b_in'] + s.reserve_b),
            reserve_b_before=s.reserve_b,
            total_lp_shares=(((0 if s.reserve_a == 0 else (((cmd.args['amount_a_in'] * s.total_lp_shares) // s.reserve_a) + (1 if ((cmd.args['amount_a_in'] * s.total_lp_shares) % s.reserve_a) < 0 else 0))) if ((0 if s.reserve_a == 0 else (((cmd.args['amount_a_in'] * s.total_lp_shares) // s.reserve_a) + (1 if ((cmd.args['amount_a_in'] * s.total_lp_shares) % s.reserve_a) < 0 else 0))) <= (0 if s.reserve_b == 0 else (((cmd.args['amount_b_in'] * s.total_lp_shares) // s.reserve_b) + (1 if ((cmd.args['amount_b_in'] * s.total_lp_shares) % s.reserve_b) < 0 else 0)))) else (0 if s.reserve_b == 0 else (((cmd.args['amount_b_in'] * s.total_lp_shares) // s.reserve_b) + (1 if ((cmd.args['amount_b_in'] * s.total_lp_shares) % s.reserve_b) < 0 else 0)))) + s.total_lp_shares),
            total_lp_shares_before=s.total_lp_shares,
        )
        effects = {
            'amounts_added': (cmd.args['amount_a_in'] + cmd.args['amount_b_in']),
            'amounts_removed': 0,
            'lp_shares_burned': 0,
            'lp_shares_minted': ((0 if new_state.reserve_a_before == 0 else (((cmd.args['amount_a_in'] * new_state.total_lp_shares_before) // new_state.reserve_a_before) + (1 if ((cmd.args['amount_a_in'] * new_state.total_lp_shares_before) % new_state.reserve_a_before) < 0 else 0))) if ((0 if new_state.reserve_a_before == 0 else (((cmd.args['amount_a_in'] * new_state.total_lp_shares_before) // new_state.reserve_a_before) + (1 if ((cmd.args['amount_a_in'] * new_state.total_lp_shares_before) % new_state.reserve_a_before) < 0 else 0))) <= (0 if new_state.reserve_b_before == 0 else (((cmd.args['amount_b_in'] * new_state.total_lp_shares_before) // new_state.reserve_b_before) + (1 if ((cmd.args['amount_b_in'] * new_state.total_lp_shares_before) % new_state.reserve_b_before) < 0 else 0)))) else (0 if new_state.reserve_b_before == 0 else (((cmd.args['amount_b_in'] * new_state.total_lp_shares_before) // new_state.reserve_b_before) + (1 if ((cmd.args['amount_b_in'] * new_state.total_lp_shares_before) % new_state.reserve_b_before) < 0 else 0)))),
        }
        ok, failed = check_invariants(new_state)
        if not ok:
            return StepResult(ok=False, error=f'post-invariant violated: {failed}')
        return StepResult(ok=True, state=new_state, effects=effects)
    elif cmd.tag == 'remove_liquidity':
        if 'lp_shares_burn' not in cmd.args or not (isinstance(cmd.args['lp_shares_burn'], int) and not isinstance(cmd.args['lp_shares_burn'], bool) and 1 <= cmd.args['lp_shares_burn'] <= 60):
            return StepResult(ok=False, error='invalid param lp_shares_burn')
        if not (((cmd.args['lp_shares_burn'] <= s.total_lp_shares) and ((s.reserve_a - (0 if s.total_lp_shares == 0 else (((cmd.args['lp_shares_burn'] * s.reserve_a) // s.total_lp_shares) + (1 if ((cmd.args['lp_shares_burn'] * s.reserve_a) % s.total_lp_shares) < 0 else 0)))) >= 1) and ((s.reserve_b - (0 if s.total_lp_shares == 0 else (((cmd.args['lp_shares_burn'] * s.reserve_b) // s.total_lp_shares) + (1 if ((cmd.args['lp_shares_burn'] * s.reserve_b) % s.total_lp_shares) < 0 else 0)))) >= 1) and ((s.total_lp_shares - cmd.args['lp_shares_burn']) >= 1))):
            return StepResult(ok=False, error='guard failed for remove_liquidity')
        # Compute updates (simultaneous)
        new_state = State(
            reserve_a=(s.reserve_a - (0 if s.total_lp_shares == 0 else (((cmd.args['lp_shares_burn'] * s.reserve_a) // s.total_lp_shares) + (1 if ((cmd.args['lp_shares_burn'] * s.reserve_a) % s.total_lp_shares) < 0 else 0)))),
            reserve_a_before=s.reserve_a,
            reserve_b=(s.reserve_b - (0 if s.total_lp_shares == 0 else (((cmd.args['lp_shares_burn'] * s.reserve_b) // s.total_lp_shares) + (1 if ((cmd.args['lp_shares_burn'] * s.reserve_b) % s.total_lp_shares) < 0 else 0)))),
            reserve_b_before=s.reserve_b,
            total_lp_shares=(s.total_lp_shares - cmd.args['lp_shares_burn']),
            total_lp_shares_before=s.total_lp_shares,
        )
        effects = {
            'amounts_added': 0,
            'amounts_removed': ((new_state.reserve_a_before - new_state.reserve_a) + (new_state.reserve_b_before - new_state.reserve_b)),
            'lp_shares_burned': cmd.args['lp_shares_burn'],
            'lp_shares_minted': 0,
        }
        ok, failed = check_invariants(new_state)
        if not ok:
            return StepResult(ok=False, error=f'post-invariant violated: {failed}')
        return StepResult(ok=True, state=new_state, effects=effects)
    else:
        return StepResult(ok=False, error=f'unknown action: {cmd.tag}')


# === Hypothesis test scaffolding ===
# Uncomment and install hypothesis to use property-based testing

# from hypothesis import given, strategies as st
# from hypothesis.stateful import RuleBasedStateMachine, rule, initialize
#
# class ModelStateMachine(RuleBasedStateMachine):
#     def __init__(self):
#         super().__init__()
#         self.state = init_state()
#
#     @initialize()
#     def init(self):
#         self.state = init_state()
#         ok, _ = check_invariants(self.state)
#         assert ok, 'init violates invariants'
#
#     # @rule(amount_a_in=st.integers(), amount_b_in=st.integers())
#     # def add_liquidity(self, amount_a_in, amount_b_in):
#     #     cmd = Command(tag='add_liquidity', args={'amount_a_in': amount_a_in, 'amount_b_in': amount_b_in})
#     #     result = step(self.state, cmd)
#     #     if result.ok:
#     #         self.state = result.state
#
#     # @rule(lp_shares_burn=st.integers())
#     # def remove_liquidity(self, lp_shares_burn):
#     #     cmd = Command(tag='remove_liquidity', args={'lp_shares_burn': lp_shares_burn})
#     #     result = step(self.state, cmd)
#     #     if result.ok:
#     #         self.state = result.state
#
# TestModel = ModelStateMachine.TestCase


def replay_trace(commands: list[tuple[str, dict[str, Any]]]) -> list[StepResult]:
    """Replay a trace of commands and return results."""
    results: list[StepResult] = []
    s = init_state()
    for tag, args in commands:
        cmd = Command(tag=tag, args=args)
        result = step(s, cmd)
        results.append(result)
        if result.ok and result.state is not None:
            s = result.state
        else:
            break
    return results


if __name__ == '__main__':
    # Quick sanity check
    s0 = init_state()
    ok, failed = check_invariants(s0)
    print(f'Initial state: {s0}')
    print(f'Invariants OK: {ok}')
    if not ok:
        print(f'  Failed: {failed}')
